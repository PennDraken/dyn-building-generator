// node_modules/@flatten-js/core/dist/main.mjs
var CCW = true;
var CW = false;
var ORIENTATION = { CCW: -1, CW: 1, NOT_ORIENTABLE: 0 };
var PIx2 = 2 * Math.PI;
var INSIDE$2 = 1;
var OUTSIDE$1 = 0;
var BOUNDARY$1 = 2;
var CONTAINS = 3;
var INTERLACE = 4;
var OVERLAP_SAME$1 = 1;
var OVERLAP_OPPOSITE$1 = 2;
var NOT_VERTEX$1 = 0;
var START_VERTEX$1 = 1;
var END_VERTEX$1 = 2;
var Constants = Object.freeze({
  __proto__: null,
  BOUNDARY: BOUNDARY$1,
  CCW,
  CONTAINS,
  CW,
  END_VERTEX: END_VERTEX$1,
  INSIDE: INSIDE$2,
  INTERLACE,
  NOT_VERTEX: NOT_VERTEX$1,
  ORIENTATION,
  OUTSIDE: OUTSIDE$1,
  OVERLAP_OPPOSITE: OVERLAP_OPPOSITE$1,
  OVERLAP_SAME: OVERLAP_SAME$1,
  PIx2,
  START_VERTEX: START_VERTEX$1
});
var DP_TOL = 1e-6;
function setTolerance(tolerance) {
  DP_TOL = tolerance;
}
function getTolerance() {
  return DP_TOL;
}
var DECIMALS = 3;
function EQ_0(x) {
  return x < DP_TOL && x > -DP_TOL;
}
function EQ(x, y) {
  return x - y < DP_TOL && x - y > -DP_TOL;
}
function GT(x, y) {
  return x - y > DP_TOL;
}
function GE(x, y) {
  return x - y > -DP_TOL;
}
function LT(x, y) {
  return x - y < -DP_TOL;
}
function LE(x, y) {
  return x - y < DP_TOL;
}
var Utils$1 = Object.freeze({
  __proto__: null,
  DECIMALS,
  EQ,
  EQ_0,
  GE,
  GT,
  LE,
  LT,
  getTolerance,
  setTolerance
});
var Flatten = {
  Utils: Utils$1,
  Errors: void 0,
  Matrix: void 0,
  Planar_set: void 0,
  Point: void 0,
  Vector: void 0,
  Line: void 0,
  Circle: void 0,
  Segment: void 0,
  Arc: void 0,
  Box: void 0,
  Edge: void 0,
  Face: void 0,
  Ray: void 0,
  Ray_shooting: void 0,
  Multiline: void 0,
  Polygon: void 0,
  Distance: void 0,
  Inversion: void 0
};
for (let c in Constants) {
  Flatten[c] = Constants[c];
}
Object.defineProperty(Flatten, "DP_TOL", {
  get: function() {
    return getTolerance();
  },
  set: function(value) {
    setTolerance(value);
  }
});
var Errors = class {
  /**
   * Throw error ILLEGAL_PARAMETERS when cannot instantiate from given parameter
   * @returns {ReferenceError}
   */
  static get ILLEGAL_PARAMETERS() {
    return new ReferenceError("Illegal Parameters");
  }
  /**
   * Throw error ZERO_DIVISION to catch situation of zero division
   * @returns {Error}
   */
  static get ZERO_DIVISION() {
    return new Error("Zero division");
  }
  /**
   * Error to throw from BooleanOperations module in case when fixBoundaryConflicts not capable to fix it
   * @returns {Error}
   */
  static get UNRESOLVED_BOUNDARY_CONFLICT() {
    return new Error("Unresolved boundary conflict in boolean operation");
  }
  /**
   * Error to throw from LinkedList:testInfiniteLoop static method
   * in case when circular loop detected in linked list
   * @returns {Error}
   */
  static get INFINITE_LOOP() {
    return new Error("Infinite loop");
  }
  static get CANNOT_COMPLETE_BOOLEAN_OPERATION() {
    return new Error("Cannot complete boolean operation");
  }
  static get CANNOT_INVOKE_ABSTRACT_METHOD() {
    return new Error("Abstract method cannot be invoked");
  }
  static get OPERATION_IS_NOT_SUPPORTED() {
    return new Error("Operation is not supported");
  }
  static get UNSUPPORTED_SHAPE_TYPE() {
    return new Error("Unsupported shape type");
  }
};
Flatten.Errors = Errors;
var LinkedList = class {
  constructor(first, last) {
    this.first = first;
    this.last = last || this.first;
  }
  [Symbol.iterator]() {
    let value = void 0;
    return {
      next: () => {
        value = value ? value.next : this.first;
        return { value, done: value === void 0 };
      }
    };
  }
  /**
   * Return number of elements in the list
   * @returns {number}
   */
  get size() {
    let counter = 0;
    for (let edge of this) {
      counter++;
    }
    return counter;
  }
  /**
   * Return array of elements from start to end,
   * If start or end not defined, take first as start, last as end
   * @returns {Array}
   */
  toArray(start = void 0, end = void 0) {
    let elements = [];
    let from = start || this.first;
    let to = end || this.last;
    let element = from;
    if (element === void 0) return elements;
    do {
      elements.push(element);
      element = element.next;
    } while (element !== to.next);
    return elements;
  }
  /**
   * Append new element to the end of the list
   * @param {LinkedListElement} element
   * @returns {LinkedList}
   */
  append(element) {
    if (this.isEmpty()) {
      this.first = element;
    } else {
      element.prev = this.last;
      this.last.next = element;
    }
    this.last = element;
    this.last.next = void 0;
    this.first.prev = void 0;
    return this;
  }
  /**
   * Insert new element to the list after elementBefore
   * @param {LinkedListElement} newElement
   * @param {LinkedListElement} elementBefore
   * @returns {LinkedList}
   */
  insert(newElement, elementBefore) {
    if (this.isEmpty()) {
      this.first = newElement;
      this.last = newElement;
    } else if (elementBefore === null || elementBefore === void 0) {
      newElement.next = this.first;
      this.first.prev = newElement;
      this.first = newElement;
    } else {
      let elementAfter = elementBefore.next;
      elementBefore.next = newElement;
      if (elementAfter) elementAfter.prev = newElement;
      newElement.prev = elementBefore;
      newElement.next = elementAfter;
      if (this.last === elementBefore)
        this.last = newElement;
    }
    this.last.next = void 0;
    this.first.prev = void 0;
    return this;
  }
  /**
   * Remove element from the list
   * @param {LinkedListElement} element
   * @returns {LinkedList}
   */
  remove(element) {
    if (element === this.first && element === this.last) {
      this.first = void 0;
      this.last = void 0;
    } else {
      if (element.prev) element.prev.next = element.next;
      if (element.next) element.next.prev = element.prev;
      if (element === this.first) {
        this.first = element.next;
      }
      if (element === this.last) {
        this.last = element.prev;
      }
    }
    return this;
  }
  /**
   * Return true if list is empty
   * @returns {boolean}
   */
  isEmpty() {
    return this.first === void 0;
  }
  /**
   * Throw an error if circular loop detected in the linked list
   * @param {LinkedListElement} first element to start iteration
   * @throws {Errors.INFINITE_LOOP}
   */
  static testInfiniteLoop(first) {
    let edge = first;
    let controlEdge = first;
    do {
      if (edge != first && edge === controlEdge) {
        throw Errors.INFINITE_LOOP;
      }
      edge = edge.next;
      controlEdge = controlEdge.next.next;
    } while (edge != first);
  }
};
var defaultAttributes = {
  stroke: "black"
};
var SVGAttributes = class {
  constructor(args = defaultAttributes) {
    for (const property in args) {
      this[property] = args[property];
    }
    this.stroke = args.stroke ?? defaultAttributes.stroke;
  }
  toAttributesString() {
    return Object.keys(this).reduce(
      (acc, key) => acc + (this[key] !== void 0 ? this.toAttrString(key, this[key]) : ""),
      ``
    );
  }
  toAttrString(key, value) {
    const SVGKey = key === "className" ? "class" : this.convertCamelToKebabCase(key);
    return value === null ? `${SVGKey} ` : `${SVGKey}="${value.toString()}" `;
  }
  convertCamelToKebabCase(str) {
    return str.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g).join("-").toLowerCase();
  }
};
function convertToString(attrs) {
  return new SVGAttributes(attrs).toAttributesString();
}
function intersectLine2Line(line1, line2) {
  let ip = [];
  let [A1, B1, C1] = line1.standard;
  let [A2, B2, C2] = line2.standard;
  let det = A1 * B2 - B1 * A2;
  let detX = C1 * B2 - B1 * C2;
  let detY = A1 * C2 - C1 * A2;
  if (!Flatten.Utils.EQ_0(det)) {
    let x, y;
    if (B1 === 0) {
      x = C1 / A1;
      y = detY / det;
    } else if (B2 === 0) {
      x = C2 / A2;
      y = detY / det;
    } else if (A1 === 0) {
      x = detX / det;
      y = C1 / B1;
    } else if (A2 === 0) {
      x = detX / det;
      y = C2 / B2;
    } else {
      x = detX / det;
      y = detY / det;
    }
    ip.push(new Flatten.Point(x, y));
  }
  return ip;
}
function intersectLine2Circle(line2, circle2) {
  let ip = [];
  let prj = circle2.pc.projectionOn(line2);
  let dist = circle2.pc.distanceTo(prj)[0];
  if (Flatten.Utils.EQ(dist, circle2.r)) {
    ip.push(prj);
  } else if (Flatten.Utils.LT(dist, circle2.r)) {
    let delta = Math.sqrt(circle2.r * circle2.r - dist * dist);
    let v_trans, pt;
    v_trans = line2.norm.rotate90CCW().multiply(delta);
    pt = prj.translate(v_trans);
    ip.push(pt);
    v_trans = line2.norm.rotate90CW().multiply(delta);
    pt = prj.translate(v_trans);
    ip.push(pt);
  }
  return ip;
}
function intersectLine2Box(line2, box2) {
  let ips = [];
  for (let seg of box2.toSegments()) {
    let ips_tmp = intersectSegment2Line(seg, line2);
    for (let pt of ips_tmp) {
      if (!ptInIntPoints(pt, ips)) {
        ips.push(pt);
      }
    }
  }
  return ips;
}
function intersectLine2Arc(line2, arc2) {
  let ip = [];
  if (intersectLine2Box(line2, arc2.box).length === 0) {
    return ip;
  }
  let circle2 = new Flatten.Circle(arc2.pc, arc2.r);
  let ip_tmp = intersectLine2Circle(line2, circle2);
  for (let pt of ip_tmp) {
    if (pt.on(arc2)) {
      ip.push(pt);
    }
  }
  return ip;
}
function intersectSegment2Line(seg, line2) {
  let ip = [];
  if (seg.ps.on(line2)) {
    ip.push(seg.ps);
  }
  if (seg.pe.on(line2) && !seg.isZeroLength()) {
    ip.push(seg.pe);
  }
  if (ip.length > 0) {
    return ip;
  }
  if (seg.isZeroLength()) {
    return ip;
  }
  if (seg.ps.leftTo(line2) && seg.pe.leftTo(line2) || !seg.ps.leftTo(line2) && !seg.pe.leftTo(line2)) {
    return ip;
  }
  let line1 = new Flatten.Line(seg.ps, seg.pe);
  return intersectLine2Line(line1, line2);
}
function intersectSegment2Segment(seg1, seg2) {
  let ip = [];
  if (seg1.box.not_intersect(seg2.box)) {
    return ip;
  }
  if (seg1.isZeroLength()) {
    if (seg1.ps.on(seg2)) {
      ip.push(seg1.ps);
    }
    return ip;
  }
  if (seg2.isZeroLength()) {
    if (seg2.ps.on(seg1)) {
      ip.push(seg2.ps);
    }
    return ip;
  }
  let line1 = new Flatten.Line(seg1.ps, seg1.pe);
  let line2 = new Flatten.Line(seg2.ps, seg2.pe);
  if (line1.incidentTo(line2)) {
    if (seg1.ps.on(seg2)) {
      ip.push(seg1.ps);
    }
    if (seg1.pe.on(seg2)) {
      ip.push(seg1.pe);
    }
    if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) {
      ip.push(seg2.ps);
    }
    if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) {
      ip.push(seg2.pe);
    }
  } else {
    let new_ip = intersectLine2Line(line1, line2);
    if (new_ip.length > 0) {
      if (isPointInSegmentBox(new_ip[0], seg1) && isPointInSegmentBox(new_ip[0], seg2)) {
        ip.push(new_ip[0]);
      }
    }
  }
  return ip;
}
function isPointInSegmentBox(point2, segment2) {
  const box2 = segment2.box;
  return Flatten.Utils.LE(point2.x, box2.xmax) && Flatten.Utils.GE(point2.x, box2.xmin) && Flatten.Utils.LE(point2.y, box2.ymax) && Flatten.Utils.GE(point2.y, box2.ymin);
}
function intersectSegment2Circle(segment2, circle2) {
  let ips = [];
  if (segment2.box.not_intersect(circle2.box)) {
    return ips;
  }
  if (segment2.isZeroLength()) {
    let [dist, _] = segment2.ps.distanceTo(circle2.pc);
    if (Flatten.Utils.EQ(dist, circle2.r)) {
      ips.push(segment2.ps);
    }
    return ips;
  }
  let line2 = new Flatten.Line(segment2.ps, segment2.pe);
  let ips_tmp = intersectLine2Circle(line2, circle2);
  for (let ip of ips_tmp) {
    if (ip.on(segment2)) {
      ips.push(ip);
    }
  }
  return ips;
}
function intersectSegment2Arc(segment2, arc2) {
  let ip = [];
  if (segment2.box.not_intersect(arc2.box)) {
    return ip;
  }
  if (segment2.isZeroLength()) {
    if (segment2.ps.on(arc2)) {
      ip.push(segment2.ps);
    }
    return ip;
  }
  let line2 = new Flatten.Line(segment2.ps, segment2.pe);
  let circle2 = new Flatten.Circle(arc2.pc, arc2.r);
  let ip_tmp = intersectLine2Circle(line2, circle2);
  for (let pt of ip_tmp) {
    if (pt.on(segment2) && pt.on(arc2)) {
      ip.push(pt);
    }
  }
  return ip;
}
function intersectSegment2Box(segment2, box2) {
  let ips = [];
  for (let seg of box2.toSegments()) {
    let ips_tmp = intersectSegment2Segment(seg, segment2);
    for (let ip of ips_tmp) {
      ips.push(ip);
    }
  }
  return ips;
}
function intersectCircle2Circle(circle1, circle2) {
  let ip = [];
  if (circle1.box.not_intersect(circle2.box)) {
    return ip;
  }
  let vec = new Flatten.Vector(circle1.pc, circle2.pc);
  let r1 = circle1.r;
  let r2 = circle2.r;
  if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2))
    return ip;
  if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {
    ip.push(circle1.pc.translate(-r1, 0));
    return ip;
  }
  let dist = circle1.pc.distanceTo(circle2.pc)[0];
  if (Flatten.Utils.GT(dist, r1 + r2))
    return ip;
  if (Flatten.Utils.LT(dist, Math.abs(r1 - r2)))
    return ip;
  vec.x /= dist;
  vec.y /= dist;
  let pt;
  if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {
    pt = circle1.pc.translate(r1 * vec.x, r1 * vec.y);
    ip.push(pt);
    return ip;
  }
  let a = r1 * r1 / (2 * dist) - r2 * r2 / (2 * dist) + dist / 2;
  let mid_pt = circle1.pc.translate(a * vec.x, a * vec.y);
  let h = Math.sqrt(r1 * r1 - a * a);
  pt = mid_pt.translate(vec.rotate90CCW().multiply(h));
  ip.push(pt);
  pt = mid_pt.translate(vec.rotate90CW().multiply(h));
  ip.push(pt);
  return ip;
}
function intersectCircle2Box(circle2, box2) {
  let ips = [];
  for (let seg of box2.toSegments()) {
    let ips_tmp = intersectSegment2Circle(seg, circle2);
    for (let ip of ips_tmp) {
      ips.push(ip);
    }
  }
  return ips;
}
function intersectArc2Arc(arc1, arc2) {
  let ip = [];
  if (arc1.box.not_intersect(arc2.box)) {
    return ip;
  }
  if (arc1.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(arc1.r, arc2.r)) {
    let pt;
    pt = arc1.start;
    if (pt.on(arc2))
      ip.push(pt);
    pt = arc1.end;
    if (pt.on(arc2))
      ip.push(pt);
    pt = arc2.start;
    if (pt.on(arc1)) ip.push(pt);
    pt = arc2.end;
    if (pt.on(arc1)) ip.push(pt);
    return ip;
  }
  let circle1 = new Flatten.Circle(arc1.pc, arc1.r);
  let circle2 = new Flatten.Circle(arc2.pc, arc2.r);
  let ip_tmp = circle1.intersect(circle2);
  for (let pt of ip_tmp) {
    if (pt.on(arc1) && pt.on(arc2)) {
      ip.push(pt);
    }
  }
  return ip;
}
function intersectArc2Circle(arc2, circle2) {
  let ip = [];
  if (arc2.box.not_intersect(circle2.box)) {
    return ip;
  }
  if (circle2.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(circle2.r, arc2.r)) {
    ip.push(arc2.start);
    ip.push(arc2.end);
    return ip;
  }
  let circle1 = circle2;
  let circle22 = new Flatten.Circle(arc2.pc, arc2.r);
  let ip_tmp = intersectCircle2Circle(circle1, circle22);
  for (let pt of ip_tmp) {
    if (pt.on(arc2)) {
      ip.push(pt);
    }
  }
  return ip;
}
function intersectArc2Box(arc2, box2) {
  let ips = [];
  for (let seg of box2.toSegments()) {
    let ips_tmp = intersectSegment2Arc(seg, arc2);
    for (let ip of ips_tmp) {
      ips.push(ip);
    }
  }
  return ips;
}
function intersectEdge2Segment(edge, segment2) {
  return edge.isSegment ? intersectSegment2Segment(edge.shape, segment2) : intersectSegment2Arc(segment2, edge.shape);
}
function intersectEdge2Arc(edge, arc2) {
  return edge.isSegment ? intersectSegment2Arc(edge.shape, arc2) : intersectArc2Arc(edge.shape, arc2);
}
function intersectEdge2Line(edge, line2) {
  return edge.isSegment ? intersectSegment2Line(edge.shape, line2) : intersectLine2Arc(line2, edge.shape);
}
function intersectEdge2Ray(edge, ray2) {
  return edge.isSegment ? intersectRay2Segment(ray2, edge.shape) : intersectRay2Arc(ray2, edge.shape);
}
function intersectEdge2Circle(edge, circle2) {
  return edge.isSegment ? intersectSegment2Circle(edge.shape, circle2) : intersectArc2Circle(edge.shape, circle2);
}
function intersectSegment2Polygon(segment2, polygon2) {
  let ip = [];
  for (let edge of polygon2.edges) {
    for (let pt of intersectEdge2Segment(edge, segment2)) {
      ip.push(pt);
    }
  }
  return ip;
}
function intersectArc2Polygon(arc2, polygon2) {
  let ip = [];
  for (let edge of polygon2.edges) {
    for (let pt of intersectEdge2Arc(edge, arc2)) {
      ip.push(pt);
    }
  }
  return ip;
}
function intersectLine2Polygon(line2, polygon2) {
  let ip = [];
  if (polygon2.isEmpty()) {
    return ip;
  }
  for (let edge of polygon2.edges) {
    for (let pt of intersectEdge2Line(edge, line2)) {
      if (!ptInIntPoints(pt, ip)) {
        ip.push(pt);
      }
    }
  }
  return line2.sortPoints(ip);
}
function intersectCircle2Polygon(circle2, polygon2) {
  let ip = [];
  if (polygon2.isEmpty()) {
    return ip;
  }
  for (let edge of polygon2.edges) {
    for (let pt of intersectEdge2Circle(edge, circle2)) {
      ip.push(pt);
    }
  }
  return ip;
}
function intersectEdge2Edge(edge1, edge2) {
  if (edge1.isSegment) {
    return intersectEdge2Segment(edge2, edge1.shape);
  } else if (edge1.isArc) {
    return intersectEdge2Arc(edge2, edge1.shape);
  } else if (edge1.isLine) {
    return intersectEdge2Line(edge2, edge1.shape);
  } else if (edge1.isRay) {
    return intersectEdge2Ray(edge2, edge1.shape);
  }
  return [];
}
function intersectEdge2Polygon(edge, polygon2) {
  let ip = [];
  if (polygon2.isEmpty() || edge.shape.box.not_intersect(polygon2.box)) {
    return ip;
  }
  let resp_edges = polygon2.edges.search(edge.shape.box);
  for (let resp_edge of resp_edges) {
    ip = [...ip, ...intersectEdge2Edge(edge, resp_edge)];
  }
  return ip;
}
function intersectMultiline2Polygon(multiline2, polygon2) {
  let ip = [];
  if (polygon2.isEmpty() || multiline2.size === 0) {
    return ip;
  }
  for (let edge of multiline2) {
    ip = [...ip, ...intersectEdge2Polygon(edge, polygon2)];
  }
  return ip;
}
function intersectPolygon2Polygon(polygon1, polygon2) {
  let ip = [];
  if (polygon1.isEmpty() || polygon2.isEmpty()) {
    return ip;
  }
  if (polygon1.box.not_intersect(polygon2.box)) {
    return ip;
  }
  for (let edge1 of polygon1.edges) {
    ip = [...ip, ...intersectEdge2Polygon(edge1, polygon2)];
  }
  return ip;
}
function intersectShape2Polygon(shape, polygon2) {
  if (shape instanceof Flatten.Line) {
    return intersectLine2Polygon(shape, polygon2);
  } else if (shape instanceof Flatten.Segment) {
    return intersectSegment2Polygon(shape, polygon2);
  } else if (shape instanceof Flatten.Arc) {
    return intersectArc2Polygon(shape, polygon2);
  } else {
    return [];
  }
}
function ptInIntPoints(new_pt, ip) {
  return ip.some((pt) => pt.equalTo(new_pt));
}
function createLineFromRay(ray2) {
  return new Flatten.Line(ray2.start, ray2.norm);
}
function intersectRay2Segment(ray2, segment2) {
  return intersectSegment2Line(segment2, createLineFromRay(ray2)).filter((pt) => ray2.contains(pt));
}
function intersectRay2Arc(ray2, arc2) {
  return intersectLine2Arc(createLineFromRay(ray2), arc2).filter((pt) => ray2.contains(pt));
}
function intersectRay2Circle(ray2, circle2) {
  return intersectLine2Circle(createLineFromRay(ray2), circle2).filter((pt) => ray2.contains(pt));
}
function intersectRay2Box(ray2, box2) {
  return intersectLine2Box(createLineFromRay(ray2), box2).filter((pt) => ray2.contains(pt));
}
function intersectRay2Line(ray2, line2) {
  return intersectLine2Line(createLineFromRay(ray2), line2).filter((pt) => ray2.contains(pt));
}
function intersectRay2Ray(ray1, ray2) {
  return intersectLine2Line(createLineFromRay(ray1), createLineFromRay(ray2)).filter((pt) => ray1.contains(pt)).filter((pt) => ray2.contains(pt));
}
function intersectRay2Polygon(ray2, polygon2) {
  return intersectLine2Polygon(createLineFromRay(ray2), polygon2).filter((pt) => ray2.contains(pt));
}
function intersectShape2Shape(shape1, shape2) {
  if (shape1.intersect && shape1.intersect instanceof Function) {
    return shape1.intersect(shape2);
  }
  throw Errors.UNSUPPORTED_SHAPE_TYPE;
}
function intersectShape2Multiline(shape, multiline2) {
  let ip = [];
  for (let edge of multiline2) {
    ip = [...ip, ...intersectShape2Shape(shape, edge.shape)];
  }
  return ip;
}
function intersectMultiline2Multiline(multiline1, multiline2) {
  let ip = [];
  for (let edge1 of multiline1) {
    for (let edge2 of multiline2) {
      ip = [...ip, ...intersectShape2Shape(edge1, edge2)];
    }
  }
  return ip;
}
var Multiline$1 = class Multiline extends LinkedList {
  constructor(...args) {
    super();
    this.isInfinite = false;
    if (args.length === 1 && args[0] instanceof Array && args[0].length > 0) {
      let validShapes = false;
      const shapes = args[0];
      const L = shapes.length;
      const anyShape = (s) => s instanceof Flatten.Segment || s instanceof Flatten.Arc || s instanceof Flatten.Ray || s instanceof Flatten.Line;
      const anyShapeExceptLine = (s) => s instanceof Flatten.Segment || s instanceof Flatten.Arc || s instanceof Flatten.Ray;
      const shapeSegmentOrArc = (s) => s instanceof Flatten.Segment || s instanceof Flatten.Arc;
      validShapes = L === 1 && anyShape(shapes[0]) || L > 1 && anyShapeExceptLine(shapes[0]) && anyShapeExceptLine(shapes[L - 1]) && shapes.slice(1, L - 1).every(shapeSegmentOrArc);
      if (validShapes) {
        this.isInfinite = shapes.some(
          (shape) => shape instanceof Flatten.Ray || shape instanceof Flatten.Line
        );
        for (let shape of shapes) {
          let edge = new Flatten.Edge(shape);
          this.append(edge);
        }
        this.setArcLength();
      } else {
        throw Flatten.Errors.ILLEGAL_PARAMETERS;
      }
    }
  }
  /**
   * (Getter) Return array of edges
   * @returns {Edge[]}
   */
  get edges() {
    return [...this];
  }
  /**
   * (Getter) Return bounding box of the multiline
   * @returns {Box}
   */
  get box() {
    return this.edges.reduce((acc, edge) => acc.merge(edge.box), new Flatten.Box());
  }
  /**
   * (Getter) Returns array of vertices
   * @returns {Point[]}
   */
  get vertices() {
    let v = this.edges.map((edge) => edge.start);
    v.push(this.last.end);
    return v;
  }
  /**
   * (Getter) Returns length of the multiline, return POSITIVE_INFINITY if multiline is infinite
   * @returns {number}
   */
  get length() {
    if (this.isEmpty()) return 0;
    if (this.isInfinite) return Number.POSITIVE_INFINITY;
    let len = 0;
    for (let edge of this) {
      len += edge.length;
    }
    return len;
  }
  /**
   * Return new cloned instance of Multiline
   * @returns {Multiline}
   */
  clone() {
    return new Multiline(this.toShapes());
  }
  /**
   * Set arc_length property for each of the edges in the multiline.
   * Arc_length of the edge is the arc length from the multiline start vertex to the edge start vertex
   */
  setArcLength() {
    for (let edge of this) {
      this.setOneEdgeArcLength(edge);
    }
  }
  setOneEdgeArcLength(edge) {
    if (edge === this.first) {
      edge.arc_length = 0;
    } else {
      edge.arc_length = edge.prev.arc_length + edge.prev.length;
    }
  }
  /**
   * Return point on multiline at given length from the start of the multiline
   * @param length
   * @returns {Point | null}
   */
  pointAtLength(length) {
    if (length > this.length || length < 0) return null;
    if (this.isInfinite) return null;
    let point2 = null;
    for (let edge of this) {
      if (length >= edge.arc_length && (edge === this.last || length < edge.next.arc_length)) {
        point2 = edge.pointAtLength(length - edge.arc_length);
        break;
      }
    }
    return point2;
  }
  /**
   * Split edge and add new vertex, return new edge inserted
   * @param {Point} pt - point on edge that will be added as new vertex
   * @param {Edge} edge - edge to split
   * @returns {Edge}
   */
  addVertex(pt, edge) {
    let shapes = edge.shape.split(pt);
    if (shapes[0] === null)
      return edge.prev;
    if (shapes[1] === null)
      return edge;
    let newEdge = new Flatten.Edge(shapes[0]);
    let edgeBefore = edge.prev;
    this.insert(newEdge, edgeBefore);
    edge.shape = shapes[1];
    return newEdge;
  }
  getChain(edgeFrom, edgeTo) {
    let edges = [];
    for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next) {
      edges.push(edge);
    }
    return edges;
  }
  /**
   * Split edges of multiline with intersection points and return mutated multiline
   * @param {Point[]} ip - array of points to be added as new vertices
   * @returns {Multiline}
   */
  split(ip) {
    for (let pt of ip) {
      let edge = this.findEdgeByPoint(pt);
      this.addVertex(pt, edge);
    }
    return this;
  }
  /**
   * Returns edge which contains given point
   * @param {Point} pt
   * @returns {Edge}
   */
  findEdgeByPoint(pt) {
    let edgeFound;
    for (let edge of this) {
      if (edge.shape.contains(pt)) {
        edgeFound = edge;
        break;
      }
    }
    return edgeFound;
  }
  /**
   * Calculate distance and shortest segment from any shape to multiline
   * @param shape
   * @returns {[number,Flatten.Segment]}
   */
  distanceTo(shape) {
    if (shape instanceof Point) {
      const [dist, shortest_segment] = Flatten.Distance.shape2multiline(shape, this);
      return [dist, shortest_segment.reverse()];
    }
    if (shape instanceof Flatten.Line) {
      const [dist, shortest_segment] = Flatten.Distance.shape2multiline(shape, this);
      return [dist, shortest_segment.reverse()];
    }
    if (shape instanceof Flatten.Circle) {
      const [dist, shortest_segment] = Flatten.Distance.shape2multiline(shape, this);
      return [dist, shortest_segment.reverse()];
    }
    if (shape instanceof Flatten.Segment) {
      const [dist, shortest_segment] = Flatten.Distance.shape2multiline(shape, this);
      return [dist, shortest_segment.reverse()];
    }
    if (shape instanceof Flatten.Arc) {
      const [dist, shortest_segment] = Flatten.Distance.shape2multiline(shape, this);
      return [dist, shortest_segment.reverse()];
    }
    if (shape instanceof Flatten.Multiline) {
      return Flatten.Distance.multiline2multiline(this, shape);
    }
    throw Flatten.Errors.UNSUPPORTED_SHAPE_TYPE;
  }
  /**
   * Calculate intersection of multiline with other shape
   * @param {Shape} shape
   * @returns {Point[]}
   */
  intersect(shape) {
    if (shape instanceof Flatten.Multiline) {
      return intersectMultiline2Multiline(this, shape);
    } else {
      return intersectShape2Multiline(shape, this);
    }
  }
  /**
   * Return true if multiline contains the shape: no point of shape lies outside
   * @param shape
   * @returns {boolean}
   */
  contains(shape) {
    if (shape instanceof Flatten.Point) {
      return this.edges.some((edge) => edge.shape.contains(shape));
    }
    throw Flatten.Errors.UNSUPPORTED_SHAPE_TYPE;
  }
  /**
   * Returns new multiline translated by vector vec
   * @param {Vector} vec
   * @returns {Multiline}
   */
  translate(vec) {
    return new Multiline(this.edges.map((edge) => edge.shape.translate(vec)));
  }
  /**
   * Return new multiline rotated by given angle around given point
   * If point omitted, rotate around origin (0,0)
   * Positive value of angle defines rotation counterclockwise, negative - clockwise
   * @param {number} angle - rotation angle in radians
   * @param {Point} center - rotation center, default is (0,0)
   * @returns {Multiline} - new rotated polygon
   */
  rotate(angle = 0, center = new Flatten.Point()) {
    return new Multiline(this.edges.map((edge) => edge.shape.rotate(angle, center)));
  }
  /**
   * Return new multiline transformed using affine transformation matrix
   * Method does not support unbounded shapes
   * @param {Matrix} matrix - affine transformation matrix
   * @returns {Multiline} - new multiline
   */
  transform(matrix2 = new Flatten.Matrix()) {
    return new Multiline(this.edges.map((edge) => edge.shape.transform(matrix2)));
  }
  /**
   * Transform multiline into array of shapes
   * @returns {Shape[]}
   */
  toShapes() {
    return this.edges.map((edge) => edge.shape.clone());
  }
  /**
   * This method returns an object that defines how data will be
   * serialized when called JSON.stringify() method
   * @returns {Object}
   */
  toJSON() {
    return this.edges.map((edge) => edge.toJSON());
  }
  /**
   * Return string to be inserted into 'points' attribute of <polyline> element
   * @returns {string}
   */
  svgPoints() {
    return this.vertices.map((p) => `${p.x},${p.y}`).join(" ");
  }
  /**
   * Return string to be assigned to 'd' attribute of <path> element
   * @returns {*}
   */
  dpath() {
    let dPathStr = `M${this.first.start.x},${this.first.start.y}`;
    for (let edge of this) {
      dPathStr += edge.svg();
    }
    return dPathStr;
  }
  /**
   * Return string to draw multiline in svg
   * @param attrs  - an object with attributes for svg path element
   * TODO: support semi-infinite Ray and infinite Line
   * @returns {string}
   */
  svg(attrs = {}) {
    let svgStr = `
<path ${convertToString({ fill: "none", ...attrs })} d="`;
    svgStr += `
M${this.first.start.x},${this.first.start.y}`;
    for (let edge of this) {
      svgStr += edge.svg();
    }
    svgStr += `" >
</path>`;
    return svgStr;
  }
};
Flatten.Multiline = Multiline$1;
var multiline = (...args) => new Flatten.Multiline(...args);
Flatten.multiline = multiline;
function addToIntPoints(edge, pt, int_points) {
  let id = int_points.length;
  let shapes = edge.shape.split(pt);
  if (shapes.length === 0) return;
  let len = 0;
  if (shapes[0] === null) {
    len = 0;
  } else if (shapes[1] === null) {
    len = edge.shape.length;
  } else {
    len = shapes[0].length;
  }
  let is_vertex = NOT_VERTEX$1;
  if (EQ(len, 0)) {
    is_vertex |= START_VERTEX$1;
  }
  if (EQ(len, edge.shape.length)) {
    is_vertex |= END_VERTEX$1;
  }
  let arc_length;
  if (len === Infinity) {
    arc_length = shapes[0].coord(pt);
  } else {
    arc_length = is_vertex & END_VERTEX$1 && edge.next && edge.next.arc_length === 0 ? 0 : edge.arc_length + len;
  }
  int_points.push({
    id,
    pt,
    arc_length,
    edge_before: edge,
    edge_after: void 0,
    face: edge.face,
    is_vertex
  });
}
function sortIntersections(intersections) {
  intersections.int_points1_sorted = getSortedArray(intersections.int_points1);
  intersections.int_points2_sorted = getSortedArray(intersections.int_points2);
}
function getSortedArray(int_points) {
  let faceMap = /* @__PURE__ */ new Map();
  let id = 0;
  for (let ip of int_points) {
    if (!faceMap.has(ip.face)) {
      faceMap.set(ip.face, id);
      id++;
    }
  }
  for (let ip of int_points) {
    ip.faceId = faceMap.get(ip.face);
  }
  let int_points_sorted = int_points.slice().sort(compareFn);
  return int_points_sorted;
}
function compareFn(ip1, ip2) {
  if (ip1.faceId < ip2.faceId) {
    return -1;
  }
  if (ip1.faceId > ip2.faceId) {
    return 1;
  }
  if (ip1.arc_length < ip2.arc_length) {
    return -1;
  }
  if (ip1.arc_length > ip2.arc_length) {
    return 1;
  }
  return 0;
}
function filterDuplicatedIntersections(intersections) {
  if (intersections.int_points1.length < 2) return;
  let do_squeeze = false;
  let int_point_ref1;
  let int_point_ref2;
  let int_point_cur1;
  let int_point_cur2;
  for (let i = 0; i < intersections.int_points1_sorted.length; i++) {
    if (intersections.int_points1_sorted[i].id === -1)
      continue;
    int_point_ref1 = intersections.int_points1_sorted[i];
    int_point_ref2 = intersections.int_points2[int_point_ref1.id];
    for (let j = i + 1; j < intersections.int_points1_sorted.length; j++) {
      int_point_cur1 = intersections.int_points1_sorted[j];
      if (!EQ(int_point_cur1.arc_length, int_point_ref1.arc_length)) {
        break;
      }
      if (int_point_cur1.id === -1)
        continue;
      int_point_cur2 = intersections.int_points2[int_point_cur1.id];
      if (int_point_cur2.id === -1)
        continue;
      if (int_point_cur1.edge_before === int_point_ref1.edge_before && int_point_cur1.edge_after === int_point_ref1.edge_after && int_point_cur2.edge_before === int_point_ref2.edge_before && int_point_cur2.edge_after === int_point_ref2.edge_after) {
        int_point_cur1.id = -1;
        int_point_cur2.id = -1;
        do_squeeze = true;
      }
    }
  }
  int_point_ref2 = intersections.int_points2_sorted[0];
  int_point_ref1 = intersections.int_points1[int_point_ref2.id];
  for (let i = 1; i < intersections.int_points2_sorted.length; i++) {
    let int_point_cur22 = intersections.int_points2_sorted[i];
    if (int_point_cur22.id === -1) continue;
    if (int_point_ref2.id === -1 || /* can't be reference if already deleted */
    !EQ(int_point_cur22.arc_length, int_point_ref2.arc_length)) {
      int_point_ref2 = int_point_cur22;
      int_point_ref1 = intersections.int_points1[int_point_ref2.id];
      continue;
    }
    let int_point_cur12 = intersections.int_points1[int_point_cur22.id];
    if (int_point_cur12.edge_before === int_point_ref1.edge_before && int_point_cur12.edge_after === int_point_ref1.edge_after && int_point_cur22.edge_before === int_point_ref2.edge_before && int_point_cur22.edge_after === int_point_ref2.edge_after) {
      int_point_cur12.id = -1;
      int_point_cur22.id = -1;
      do_squeeze = true;
    }
  }
  if (do_squeeze) {
    intersections.int_points1 = intersections.int_points1.filter((int_point) => int_point.id >= 0);
    intersections.int_points2 = intersections.int_points2.filter((int_point) => int_point.id >= 0);
    intersections.int_points1.forEach((int_point, index) => int_point.id = index);
    intersections.int_points2.forEach((int_point, index) => int_point.id = index);
  }
}
function initializeInclusionFlags(int_points) {
  for (let int_point of int_points) {
    if (int_point.edge_before) {
      int_point.edge_before.bvStart = void 0;
      int_point.edge_before.bvEnd = void 0;
      int_point.edge_before.bv = void 0;
      int_point.edge_before.overlap = void 0;
    }
    if (int_point.edge_after) {
      int_point.edge_after.bvStart = void 0;
      int_point.edge_after.bvEnd = void 0;
      int_point.edge_after.bv = void 0;
      int_point.edge_after.overlap = void 0;
    }
  }
  for (let int_point of int_points) {
    if (int_point.edge_before) int_point.edge_before.bvEnd = BOUNDARY$1;
    if (int_point.edge_after) int_point.edge_after.bvStart = BOUNDARY$1;
  }
}
function calculateInclusionFlags(int_points, polygon2) {
  for (let int_point of int_points) {
    if (int_point.edge_before) int_point.edge_before.setInclusion(polygon2);
    if (int_point.edge_after) int_point.edge_after.setInclusion(polygon2);
  }
}
function setOverlappingFlags(intersections) {
  let cur_face = void 0;
  let first_int_point_in_face_id = void 0;
  let next_int_point1 = void 0;
  let num_int_points = intersections.int_points1.length;
  for (let i = 0; i < num_int_points; i++) {
    let cur_int_point1 = intersections.int_points1_sorted[i];
    if (cur_int_point1.face !== cur_face) {
      first_int_point_in_face_id = i;
      cur_face = cur_int_point1.face;
    }
    let int_points_cur_pool_start = i;
    let int_points_cur_pool_num = intPointsPoolCount(intersections.int_points1_sorted, i, cur_face);
    let next_int_point_id;
    if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points && intersections.int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {
      next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;
    } else {
      next_int_point_id = first_int_point_in_face_id;
    }
    let int_points_next_pool_num = intPointsPoolCount(intersections.int_points1_sorted, next_int_point_id, cur_face);
    next_int_point1 = null;
    for (let j = next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {
      let next_int_point1_tmp = intersections.int_points1_sorted[j];
      if (next_int_point1_tmp.face === cur_face && intersections.int_points2[next_int_point1_tmp.id].face === intersections.int_points2[cur_int_point1.id].face) {
        next_int_point1 = next_int_point1_tmp;
        break;
      }
    }
    if (next_int_point1 === null)
      continue;
    let edge_from1 = cur_int_point1.edge_after;
    let edge_to1 = next_int_point1.edge_before;
    if (!(edge_from1.bv === BOUNDARY$1 && edge_to1.bv === BOUNDARY$1))
      continue;
    if (edge_from1 !== edge_to1)
      continue;
    let cur_int_point2 = intersections.int_points2[cur_int_point1.id];
    let next_int_point2 = intersections.int_points2[next_int_point1.id];
    let edge_from2 = cur_int_point2.edge_after;
    let edge_to2 = next_int_point2.edge_before;
    if (!(edge_from2.bv === BOUNDARY$1 && edge_to2.bv === BOUNDARY$1 && edge_from2 === edge_to2)) {
      cur_int_point2 = intersections.int_points2[next_int_point1.id];
      next_int_point2 = intersections.int_points2[cur_int_point1.id];
      edge_from2 = cur_int_point2.edge_after;
      edge_to2 = next_int_point2.edge_before;
    }
    if (!(edge_from2.bv === BOUNDARY$1 && edge_to2.bv === BOUNDARY$1 && edge_from2 === edge_to2))
      continue;
    edge_from1.setOverlap(edge_from2);
  }
}
function intPointsPoolCount(int_points, cur_int_point_num, cur_face) {
  let int_point_current;
  let int_point_next;
  let int_points_pool_num = 1;
  if (int_points.length === 1) return 1;
  int_point_current = int_points[cur_int_point_num];
  for (let i = cur_int_point_num + 1; i < int_points.length; i++) {
    if (int_point_current.face !== cur_face) {
      break;
    }
    int_point_next = int_points[i];
    if (!(int_point_next.pt.equalTo(int_point_current.pt) && int_point_next.edge_before === int_point_current.edge_before && int_point_next.edge_after === int_point_current.edge_after)) {
      break;
    }
    int_points_pool_num++;
  }
  return int_points_pool_num;
}
function splitByIntersections(polygon2, int_points) {
  if (!int_points) return;
  for (let int_point of int_points) {
    let edge = int_point.edge_before;
    int_point.is_vertex = NOT_VERTEX$1;
    if (edge.shape.start && edge.shape.start.equalTo(int_point.pt)) {
      int_point.is_vertex |= START_VERTEX$1;
    }
    if (edge.shape.end && edge.shape.end.equalTo(int_point.pt)) {
      int_point.is_vertex |= END_VERTEX$1;
    }
    if (int_point.is_vertex & START_VERTEX$1) {
      int_point.edge_before = edge.prev;
      if (edge.prev) {
        int_point.is_vertex = END_VERTEX$1;
      }
      continue;
    }
    if (int_point.is_vertex & END_VERTEX$1) {
      continue;
    }
    let newEdge = polygon2.addVertex(int_point.pt, edge);
    int_point.edge_before = newEdge;
  }
  for (let int_point of int_points) {
    if (int_point.edge_before) {
      int_point.edge_after = int_point.edge_before.next;
    } else {
      if (polygon2 instanceof Multiline$1 && int_point.is_vertex & START_VERTEX$1) {
        int_point.edge_after = polygon2.first;
      }
    }
  }
}
function insertBetweenIntPoints(int_point1, int_point2, new_edges) {
  const edge_before = int_point1.edge_before;
  const edge_after = int_point2.edge_after;
  const len = new_edges.length;
  edge_before.next = new_edges[0];
  new_edges[0].prev = edge_before;
  new_edges[len - 1].next = edge_after;
  edge_after.prev = new_edges[len - 1];
}
var smart_intersections = Object.freeze({
  __proto__: null,
  addToIntPoints,
  calculateInclusionFlags,
  filterDuplicatedIntersections,
  getSortedArray,
  initializeInclusionFlags,
  insertBetweenIntPoints,
  intPointsPoolCount,
  setOverlappingFlags,
  sortIntersections,
  splitByIntersections
});
var { INSIDE: INSIDE$1, OUTSIDE, BOUNDARY, OVERLAP_SAME, OVERLAP_OPPOSITE } = Constants;
var { NOT_VERTEX, START_VERTEX, END_VERTEX } = Constants;
var BOOLEAN_UNION = 1;
var BOOLEAN_INTERSECT = 2;
var BOOLEAN_SUBTRACT = 3;
function unify(polygon1, polygon2) {
  let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_UNION, true);
  return res_poly;
}
function subtract(polygon1, polygon2) {
  let polygon2_tmp = polygon2.clone();
  let polygon2_reversed = polygon2_tmp.reverse();
  let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2_reversed, BOOLEAN_SUBTRACT, true);
  return res_poly;
}
function intersect$1(polygon1, polygon2) {
  let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, true);
  return res_poly;
}
function innerClip(polygon1, polygon2) {
  let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, false);
  let clip_shapes1 = [];
  for (let face of res_poly.faces) {
    clip_shapes1 = [...clip_shapes1, ...[...face.edges].map((edge) => edge.shape)];
  }
  let clip_shapes2 = [];
  for (let face of wrk_poly.faces) {
    clip_shapes2 = [...clip_shapes2, ...[...face.edges].map((edge) => edge.shape)];
  }
  return [clip_shapes1, clip_shapes2];
}
function outerClip(polygon1, polygon2) {
  let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_SUBTRACT, false);
  let clip_shapes1 = [];
  for (let face of res_poly.faces) {
    clip_shapes1 = [...clip_shapes1, ...[...face.edges].map((edge) => edge.shape)];
  }
  return clip_shapes1;
}
function calculateIntersections(polygon1, polygon2) {
  let res_poly = polygon1.clone();
  let wrk_poly = polygon2.clone();
  let intersections = getIntersections(res_poly, wrk_poly);
  sortIntersections(intersections);
  splitByIntersections(res_poly, intersections.int_points1_sorted);
  splitByIntersections(wrk_poly, intersections.int_points2_sorted);
  filterDuplicatedIntersections(intersections);
  sortIntersections(intersections);
  let ip_sorted1 = intersections.int_points1_sorted.map((int_point) => int_point.pt);
  let ip_sorted2 = intersections.int_points2_sorted.map((int_point) => int_point.pt);
  return [ip_sorted1, ip_sorted2];
}
function filterNotRelevantEdges(res_poly, wrk_poly, intersections, op) {
  let notIntersectedFacesRes = getNotIntersectedFaces(res_poly, intersections.int_points1);
  let notIntersectedFacesWrk = getNotIntersectedFaces(wrk_poly, intersections.int_points2);
  calcInclusionForNotIntersectedFaces(notIntersectedFacesRes, wrk_poly);
  calcInclusionForNotIntersectedFaces(notIntersectedFacesWrk, res_poly);
  initializeInclusionFlags(intersections.int_points1);
  initializeInclusionFlags(intersections.int_points2);
  calculateInclusionFlags(intersections.int_points1, wrk_poly);
  calculateInclusionFlags(intersections.int_points2, res_poly);
  while (fixBoundaryConflicts(res_poly, wrk_poly, intersections.int_points1, intersections.int_points1_sorted, intersections.int_points2, intersections)) ;
  setOverlappingFlags(intersections);
  removeNotRelevantChains(res_poly, op, intersections.int_points1_sorted, true);
  removeNotRelevantChains(wrk_poly, op, intersections.int_points2_sorted, false);
  removeNotRelevantNotIntersectedFaces(res_poly, notIntersectedFacesRes, op, true);
  removeNotRelevantNotIntersectedFaces(wrk_poly, notIntersectedFacesWrk, op, false);
}
function swapLinksAndRestore(res_poly, wrk_poly, intersections, op) {
  copyWrkToRes(res_poly, wrk_poly, op, intersections.int_points2);
  swapLinks(res_poly, wrk_poly, intersections);
  removeOldFaces(res_poly, intersections.int_points1);
  removeOldFaces(wrk_poly, intersections.int_points2);
  restoreFaces(res_poly, intersections.int_points1, intersections.int_points2);
  restoreFaces(res_poly, intersections.int_points2, intersections.int_points1);
}
function booleanOpBinary(polygon1, polygon2, op, restore) {
  let res_poly = polygon1.clone();
  let wrk_poly = polygon2.clone();
  let intersections = getIntersections(res_poly, wrk_poly);
  sortIntersections(intersections);
  splitByIntersections(res_poly, intersections.int_points1_sorted);
  splitByIntersections(wrk_poly, intersections.int_points2_sorted);
  filterDuplicatedIntersections(intersections);
  sortIntersections(intersections);
  filterNotRelevantEdges(res_poly, wrk_poly, intersections, op);
  if (restore) {
    swapLinksAndRestore(res_poly, wrk_poly, intersections, op);
  }
  return [res_poly, wrk_poly];
}
function getIntersections(polygon1, polygon2) {
  let intersections = {
    int_points1: [],
    int_points2: []
  };
  for (let edge1 of polygon1.edges) {
    let resp = polygon2.edges.search(edge1.box);
    for (let edge2 of resp) {
      let ip = edge1.shape.intersect(edge2.shape);
      for (let pt of ip) {
        addToIntPoints(edge1, pt, intersections.int_points1);
        addToIntPoints(edge2, pt, intersections.int_points2);
      }
    }
  }
  return intersections;
}
function getNotIntersectedFaces(poly, int_points) {
  let notIntersected = [];
  for (let face of poly.faces) {
    if (!int_points.find((ip) => ip.face === face)) {
      notIntersected.push(face);
    }
  }
  return notIntersected;
}
function calcInclusionForNotIntersectedFaces(notIntersectedFaces, poly2) {
  for (let face of notIntersectedFaces) {
    face.first.bv = face.first.bvStart = face.first.bvEnd = void 0;
    face.first.setInclusion(poly2);
  }
}
function fixBoundaryConflicts(poly1, poly2, int_points1, int_points1_sorted, int_points2, intersections) {
  let cur_face;
  let first_int_point_in_face_id;
  let next_int_point1;
  let num_int_points = int_points1_sorted.length;
  let iterate_more = false;
  for (let i = 0; i < num_int_points; i++) {
    let cur_int_point1 = int_points1_sorted[i];
    if (cur_int_point1.face !== cur_face) {
      first_int_point_in_face_id = i;
      cur_face = cur_int_point1.face;
    }
    let int_points_cur_pool_start = i;
    let int_points_cur_pool_num = intPointsPoolCount(int_points1_sorted, i, cur_face);
    let next_int_point_id;
    if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points && int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {
      next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;
    } else {
      next_int_point_id = first_int_point_in_face_id;
    }
    let int_points_next_pool_num = intPointsPoolCount(int_points1_sorted, next_int_point_id, cur_face);
    next_int_point1 = null;
    for (let j = next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {
      let next_int_point1_tmp = int_points1_sorted[j];
      if (next_int_point1_tmp.face === cur_face && int_points2[next_int_point1_tmp.id].face === int_points2[cur_int_point1.id].face) {
        next_int_point1 = next_int_point1_tmp;
        break;
      }
    }
    if (next_int_point1 === null)
      continue;
    let edge_from1 = cur_int_point1.edge_after;
    let edge_to1 = next_int_point1.edge_before;
    if (edge_from1.bv === BOUNDARY && edge_to1.bv != BOUNDARY) {
      edge_from1.bv = edge_to1.bv;
      continue;
    }
    if (edge_from1.bv != BOUNDARY && edge_to1.bv === BOUNDARY) {
      edge_to1.bv = edge_from1.bv;
      continue;
    }
    if (edge_from1.bv === BOUNDARY && edge_to1.bv === BOUNDARY && edge_from1 != edge_to1 || (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE || edge_from1.bv === OUTSIDE && edge_to1.bv === INSIDE$1)) {
      let edge_tmp = edge_from1.next;
      while (edge_tmp != edge_to1) {
        edge_tmp.bvStart = void 0;
        edge_tmp.bvEnd = void 0;
        edge_tmp.bv = void 0;
        edge_tmp.setInclusion(poly2);
        edge_tmp = edge_tmp.next;
      }
    }
    if (edge_from1.bv === BOUNDARY && edge_to1.bv === BOUNDARY && edge_from1 != edge_to1) {
      let edge_tmp = edge_from1.next;
      let new_bv;
      while (edge_tmp != edge_to1) {
        if (edge_tmp.bv != BOUNDARY) {
          if (new_bv === void 0) {
            new_bv = edge_tmp.bv;
          } else {
            if (edge_tmp.bv != new_bv) {
              throw Errors.UNRESOLVED_BOUNDARY_CONFLICT;
            }
          }
        }
        edge_tmp = edge_tmp.next;
      }
      if (new_bv != void 0) {
        edge_from1.bv = new_bv;
        edge_to1.bv = new_bv;
      }
      continue;
    }
    if (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE || edge_from1.bv === OUTSIDE && edge_to1.bv === INSIDE$1) {
      let edge_tmp = edge_from1;
      while (edge_tmp != edge_to1) {
        if (edge_tmp.bvStart === edge_from1.bv && edge_tmp.bvEnd === edge_to1.bv) {
          let [dist, segment2] = edge_tmp.shape.distanceTo(poly2);
          if (dist < 10 * Flatten.DP_TOL) {
            addToIntPoints(edge_tmp, segment2.ps, int_points1);
            let int_point1 = int_points1[int_points1.length - 1];
            if (int_point1.is_vertex & START_VERTEX) {
              int_point1.edge_after = edge_tmp;
              int_point1.edge_before = edge_tmp.prev;
              edge_tmp.bvStart = BOUNDARY;
              edge_tmp.bv = void 0;
              edge_tmp.setInclusion(poly2);
            } else if (int_point1.is_vertex & END_VERTEX) {
              int_point1.edge_after = edge_tmp.next;
              edge_tmp.bvEnd = BOUNDARY;
              edge_tmp.bv = void 0;
              edge_tmp.setInclusion(poly2);
            } else {
              let newEdge1 = poly2.addVertex(int_point1.pt, edge_tmp);
              int_point1.edge_before = newEdge1;
              int_point1.edge_after = newEdge1.next;
              newEdge1.setInclusion(poly2);
              newEdge1.next.bvStart = BOUNDARY;
              newEdge1.next.bvEnd = void 0;
              newEdge1.next.bv = void 0;
              newEdge1.next.setInclusion(poly2);
            }
            let edge2 = poly2.findEdgeByPoint(segment2.pe);
            addToIntPoints(edge2, segment2.pe, int_points2);
            let int_point2 = int_points2[int_points2.length - 1];
            if (int_point2.is_vertex & START_VERTEX) {
              int_point2.edge_after = edge2;
              int_point2.edge_before = edge2.prev;
            } else if (int_point2.is_vertex & END_VERTEX) {
              int_point2.edge_after = edge2.next;
            } else {
              let int_point2_edge_after = int_points2.find((int_point) => int_point.edge_after === edge2);
              let newEdge2 = poly2.addVertex(int_point2.pt, edge2);
              int_point2.edge_before = newEdge2;
              int_point2.edge_after = newEdge2.next;
              if (int_point2_edge_after)
                int_point2_edge_after.edge_after = newEdge2;
              newEdge2.bvStart = void 0;
              newEdge2.bvEnd = BOUNDARY;
              newEdge2.bv = void 0;
              newEdge2.setInclusion(poly1);
              newEdge2.next.bvStart = BOUNDARY;
              newEdge2.next.bvEnd = void 0;
              newEdge2.next.bv = void 0;
              newEdge2.next.setInclusion(poly1);
            }
            sortIntersections(intersections);
            iterate_more = true;
            break;
          }
        }
        edge_tmp = edge_tmp.next;
      }
      if (iterate_more)
        break;
      throw Errors.UNRESOLVED_BOUNDARY_CONFLICT;
    }
  }
  return iterate_more;
}
function removeNotRelevantChains(polygon2, op, int_points, is_res_polygon) {
  if (!int_points) return;
  let cur_face = void 0;
  let first_int_point_in_face_num = void 0;
  let int_point_current;
  let int_point_next;
  for (let i = 0; i < int_points.length; i++) {
    int_point_current = int_points[i];
    if (int_point_current.face !== cur_face) {
      first_int_point_in_face_num = i;
      cur_face = int_point_current.face;
    }
    if (cur_face.isEmpty())
      continue;
    let int_points_from_pull_start = i;
    let int_points_from_pull_num = intPointsPoolCount(int_points, i, cur_face);
    let next_int_point_num;
    if (int_points_from_pull_start + int_points_from_pull_num < int_points.length && int_points[int_points_from_pull_start + int_points_from_pull_num].face === int_point_current.face) {
      next_int_point_num = int_points_from_pull_start + int_points_from_pull_num;
    } else {
      next_int_point_num = first_int_point_in_face_num;
    }
    int_point_next = int_points[next_int_point_num];
    let int_points_to_pull_start = next_int_point_num;
    let int_points_to_pull_num = intPointsPoolCount(int_points, int_points_to_pull_start, cur_face);
    let edge_from = int_point_current.edge_after;
    let edge_to = int_point_next.edge_before;
    if (edge_from.bv === INSIDE$1 && edge_to.bv === INSIDE$1 && op === BOOLEAN_UNION || edge_from.bv === OUTSIDE && edge_to.bv === OUTSIDE && op === BOOLEAN_INTERSECT || (edge_from.bv === OUTSIDE || edge_to.bv === OUTSIDE) && op === BOOLEAN_SUBTRACT && !is_res_polygon || (edge_from.bv === INSIDE$1 || edge_to.bv === INSIDE$1) && op === BOOLEAN_SUBTRACT && is_res_polygon || edge_from.bv === BOUNDARY && edge_to.bv === BOUNDARY && edge_from.overlap & OVERLAP_SAME && is_res_polygon || edge_from.bv === BOUNDARY && edge_to.bv === BOUNDARY && edge_from.overlap & OVERLAP_OPPOSITE) {
      polygon2.removeChain(cur_face, edge_from, edge_to);
      for (let k = int_points_from_pull_start; k < int_points_from_pull_start + int_points_from_pull_num; k++) {
        int_points[k].edge_after = void 0;
      }
      for (let k = int_points_to_pull_start; k < int_points_to_pull_start + int_points_to_pull_num; k++) {
        int_points[k].edge_before = void 0;
      }
    }
    i += int_points_from_pull_num - 1;
  }
}
function copyWrkToRes(res_polygon, wrk_polygon, op, int_points) {
  for (let face of wrk_polygon.faces) {
    for (let edge of face) {
      res_polygon.edges.add(edge);
    }
    if (
      /*(op === BOOLEAN_UNION || op == BOOLEAN_SUBTRACT) &&*/
      int_points.find((ip) => ip.face === face) === void 0
    ) {
      res_polygon.addFace(face.first, face.last);
    }
  }
}
function swapLinks(res_polygon, wrk_polygon, intersections) {
  if (intersections.int_points1.length === 0) return;
  for (let i = 0; i < intersections.int_points1.length; i++) {
    let int_point1 = intersections.int_points1[i];
    let int_point2 = intersections.int_points2[i];
    if (int_point1.edge_before !== void 0 && int_point1.edge_after === void 0) {
      if (int_point2.edge_before === void 0 && int_point2.edge_after !== void 0) {
        int_point1.edge_before.next = int_point2.edge_after;
        int_point2.edge_after.prev = int_point1.edge_before;
        int_point1.edge_after = int_point2.edge_after;
        int_point2.edge_before = int_point1.edge_before;
      }
    }
    if (int_point2.edge_before !== void 0 && int_point2.edge_after === void 0) {
      if (int_point1.edge_before === void 0 && int_point1.edge_after !== void 0) {
        int_point2.edge_before.next = int_point1.edge_after;
        int_point1.edge_after.prev = int_point2.edge_before;
        int_point2.edge_after = int_point1.edge_after;
        int_point1.edge_before = int_point2.edge_before;
      }
    }
    if (int_point1.edge_before !== void 0 && int_point1.edge_after === void 0) {
      for (let int_point of intersections.int_points1_sorted) {
        if (int_point === int_point1) continue;
        if (int_point.edge_before === void 0 && int_point.edge_after !== void 0) {
          if (int_point.pt.equalTo(int_point1.pt)) {
            int_point1.edge_before.next = int_point.edge_after;
            int_point.edge_after.prev = int_point1.edge_before;
            int_point1.edge_after = int_point.edge_after;
            int_point.edge_before = int_point1.edge_before;
          }
        }
      }
    }
    if (int_point2.edge_before !== void 0 && int_point2.edge_after === void 0) {
      for (let int_point of intersections.int_points2_sorted) {
        if (int_point === int_point2) continue;
        if (int_point.edge_before === void 0 && int_point.edge_after !== void 0) {
          if (int_point.pt.equalTo(int_point2.pt)) {
            int_point2.edge_before.next = int_point.edge_after;
            int_point.edge_after.prev = int_point2.edge_before;
            int_point2.edge_after = int_point.edge_after;
            int_point.edge_before = int_point2.edge_before;
          }
        }
      }
    }
  }
}
function removeOldFaces(polygon2, int_points) {
  for (let int_point of int_points) {
    polygon2.faces.delete(int_point.face);
    int_point.face = void 0;
    if (int_point.edge_before)
      int_point.edge_before.face = void 0;
    if (int_point.edge_after)
      int_point.edge_after.face = void 0;
  }
}
function restoreFaces(polygon2, int_points, other_int_points) {
  for (let int_point of int_points) {
    if (int_point.edge_before === void 0 || int_point.edge_after === void 0)
      continue;
    if (int_point.face)
      continue;
    if (int_point.edge_after.face || int_point.edge_before.face)
      continue;
    let first = int_point.edge_after;
    let last = int_point.edge_before;
    try {
      LinkedList.testInfiniteLoop(first);
    } catch (error) {
      throw Errors.CANNOT_COMPLETE_BOOLEAN_OPERATION;
    }
    let face = polygon2.addFace(first, last);
    for (let int_point_tmp of int_points) {
      if (int_point_tmp.edge_before && int_point_tmp.edge_after && int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {
        int_point_tmp.face = face;
      }
    }
    for (let int_point_tmp of other_int_points) {
      if (int_point_tmp.edge_before && int_point_tmp.edge_after && int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {
        int_point_tmp.face = face;
      }
    }
  }
}
function removeNotRelevantNotIntersectedFaces(polygon2, notIntersectedFaces, op, is_res_polygon) {
  for (let face of notIntersectedFaces) {
    let rel = face.first.bv;
    if (op === BOOLEAN_UNION && rel === INSIDE$1 || op === BOOLEAN_SUBTRACT && rel === INSIDE$1 && is_res_polygon || op === BOOLEAN_SUBTRACT && rel === OUTSIDE && !is_res_polygon || op === BOOLEAN_INTERSECT && rel === OUTSIDE) {
      polygon2.deleteFace(face);
    }
  }
}
var BooleanOperations = Object.freeze({
  __proto__: null,
  BOOLEAN_INTERSECT,
  BOOLEAN_SUBTRACT,
  BOOLEAN_UNION,
  calculateIntersections,
  innerClip,
  intersect: intersect$1,
  outerClip,
  removeNotRelevantChains,
  removeOldFaces,
  restoreFaces,
  subtract,
  unify
});
var EQUAL = RegExp("T.F..FFF.|T.F...F..");
var INTERSECT = RegExp("T........|.T.......|...T.....|....T....");
var TOUCH = RegExp("FT.......|F..T.....|F...T....");
var INSIDE = RegExp("T.F..F...");
var COVERED = RegExp("T.F..F...|.TF..F...|..FT.F...|..F.TF...");
var DE9IM = class {
  /**
   * Create new instance of DE9IM matrix
   */
  constructor() {
    this.m = new Array(9).fill(void 0);
  }
  /**
   * Get Interior To Interior intersection
   * @returns {Shape[] | undefined}
   */
  get I2I() {
    return this.m[0];
  }
  /**
   * Set Interior To Interior intersection
   * @param geom
   */
  set I2I(geom) {
    this.m[0] = geom;
  }
  /**
   * Get Interior To Boundary intersection
   * @returns {Shape[] | undefined}
   */
  get I2B() {
    return this.m[1];
  }
  /**
   * Set Interior to Boundary intersection
   * @param geomc
   */
  set I2B(geom) {
    this.m[1] = geom;
  }
  /**
   * Get Interior To Exterior intersection
   * @returns {Shape[] | undefined}
   */
  get I2E() {
    return this.m[2];
  }
  /**
   * Set Interior to Exterior intersection
   * @param geom
   */
  set I2E(geom) {
    this.m[2] = geom;
  }
  /**
   * Get Boundary To Interior intersection
   * @returns {Shape[] | undefined}
   */
  get B2I() {
    return this.m[3];
  }
  /**
   * Set Boundary to Interior intersection
   * @param geom
   */
  set B2I(geom) {
    this.m[3] = geom;
  }
  /**
   * Get Boundary To Boundary intersection
   * @returns {Shape[] | undefined}
   */
  get B2B() {
    return this.m[4];
  }
  /**
   * Set Boundary to Boundary intersection
   * @param geom
   */
  set B2B(geom) {
    this.m[4] = geom;
  }
  /**
   * Get Boundary To Exterior intersection
   * @returns {Shape[] | undefined}
   */
  get B2E() {
    return this.m[5];
  }
  /**
   * Set Boundary to Exterior intersection
   * @param geom
   */
  set B2E(geom) {
    this.m[5] = geom;
  }
  /**
   * Get Exterior To Interior intersection
   * @returns {Shape[] | undefined}
   */
  get E2I() {
    return this.m[6];
  }
  /**
   * Set Exterior to Interior intersection
   * @param geom
   */
  set E2I(geom) {
    this.m[6] = geom;
  }
  /**
   * Get Exterior To Boundary intersection
   * @returns {Shape[] | undefined}
   */
  get E2B() {
    return this.m[7];
  }
  /**
   * Set Exterior to Boundary intersection
   * @param geom
   */
  set E2B(geom) {
    this.m[7] = geom;
  }
  /**
   * Get Exterior to Exterior intersection
   * @returns {Shape[] | undefined}
   */
  get E2E() {
    return this.m[8];
  }
  /**
   * Set Exterior to Exterior intersection
   * @param geom
   */
  set E2E(geom) {
    this.m[8] = geom;
  }
  /**
   * Return de9im matrix as string where<br/>
   * - intersection is 'T'<br/>
   * - not intersected is 'F'<br/>
   * - not relevant is '*'<br/>
   * For example, string 'FF**FF****' means 'DISJOINT'
   * @returns {string}
   */
  toString() {
    return this.m.map((e) => {
      if (e instanceof Array && e.length > 0) {
        return "T";
      } else if (e instanceof Array && e.length === 0) {
        return "F";
      } else {
        return "*";
      }
    }).join("");
  }
  equal() {
    return EQUAL.test(this.toString());
  }
  intersect() {
    return INTERSECT.test(this.toString());
  }
  touch() {
    return TOUCH.test(this.toString());
  }
  inside() {
    return INSIDE.test(this.toString());
  }
  covered() {
    return COVERED.test(this.toString());
  }
};
function ray_shoot(polygon2, point2) {
  let contains = void 0;
  let ray2 = new Flatten.Ray(point2);
  let line2 = new Flatten.Line(ray2.pt, ray2.norm);
  const searchBox = new Flatten.Box(
    ray2.box.xmin - Flatten.DP_TOL,
    ray2.box.ymin - Flatten.DP_TOL,
    ray2.box.xmax,
    ray2.box.ymax + Flatten.DP_TOL
  );
  if (polygon2.box.not_intersect(searchBox)) {
    return Flatten.OUTSIDE;
  }
  let resp_edges = polygon2.edges.search(searchBox);
  if (resp_edges.length === 0) {
    return Flatten.OUTSIDE;
  }
  for (let edge of resp_edges) {
    if (edge.shape.contains(point2)) {
      return Flatten.BOUNDARY;
    }
  }
  let faces = [...polygon2.faces];
  let intersections = [];
  for (let edge of resp_edges) {
    for (let ip of ray2.intersect(edge.shape)) {
      if (ip.equalTo(point2)) {
        return Flatten.BOUNDARY;
      }
      intersections.push({
        pt: ip,
        edge,
        face_index: faces.indexOf(edge.face)
      });
    }
  }
  intersections.sort((i1, i2) => {
    if (LT(i1.pt.x, i2.pt.x)) {
      return -1;
    }
    if (GT(i1.pt.x, i2.pt.x)) {
      return 1;
    }
    if (i1.face_index < i2.face_index) {
      return -1;
    }
    if (i1.face_index > i2.face_index) {
      return 1;
    }
    if (i1.edge.arc_length < i2.edge.arc_length) {
      return -1;
    }
    if (i1.edge.arc_length > i2.edge.arc_length) {
      return 1;
    }
    return 0;
  });
  let counter = 0;
  for (let i = 0; i < intersections.length; i++) {
    let intersection = intersections[i];
    if (intersection.pt.equalTo(intersection.edge.shape.start)) {
      if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) && intersection.face_index === intersections[i - 1].face_index && intersection.edge.prev === intersections[i - 1].edge) {
        continue;
      }
      let prev_edge = intersection.edge.prev;
      while (EQ_0(prev_edge.length)) {
        prev_edge = prev_edge.prev;
      }
      let prev_tangent = prev_edge.shape.tangentInEnd();
      let prev_point = intersection.pt.translate(prev_tangent);
      let cur_tangent = intersection.edge.shape.tangentInStart();
      let cur_point = intersection.pt.translate(cur_tangent);
      let prev_on_the_left = prev_point.leftTo(line2);
      let cur_on_the_left = cur_point.leftTo(line2);
      if (prev_on_the_left && !cur_on_the_left || !prev_on_the_left && cur_on_the_left) {
        counter++;
      }
    } else if (intersection.pt.equalTo(intersection.edge.shape.end)) {
      if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) && intersection.face_index === intersections[i - 1].face_index && intersection.edge.next === intersections[i - 1].edge) {
        continue;
      }
      let next_edge = intersection.edge.next;
      while (EQ_0(next_edge.length)) {
        next_edge = next_edge.next;
      }
      let next_tangent = next_edge.shape.tangentInStart();
      let next_point = intersection.pt.translate(next_tangent);
      let cur_tangent = intersection.edge.shape.tangentInEnd();
      let cur_point = intersection.pt.translate(cur_tangent);
      let next_on_the_left = next_point.leftTo(line2);
      let cur_on_the_left = cur_point.leftTo(line2);
      if (next_on_the_left && !cur_on_the_left || !next_on_the_left && cur_on_the_left) {
        counter++;
      }
    } else {
      if (intersection.edge.shape instanceof Flatten.Segment) {
        counter++;
      } else {
        let box2 = intersection.edge.shape.box;
        if (!(EQ(intersection.pt.y, box2.ymin) || EQ(intersection.pt.y, box2.ymax))) {
          counter++;
        }
      }
    }
  }
  contains = counter % 2 === 1 ? INSIDE$2 : OUTSIDE$1;
  return contains;
}
function equal(shape1, shape2) {
  return relate(shape1, shape2).equal();
}
function intersect(shape1, shape2) {
  return relate(shape1, shape2).intersect();
}
function touch(shape1, shape2) {
  return relate(shape1, shape2).touch();
}
function disjoint(shape1, shape2) {
  return !intersect(shape1, shape2);
}
function inside(shape1, shape2) {
  return relate(shape1, shape2).inside();
}
function covered(shape1, shape2) {
  return relate(shape1, shape2).covered();
}
function contain(shape1, shape2) {
  return inside(shape2, shape1);
}
function cover(shape1, shape2) {
  return covered(shape2, shape1);
}
function relate(shape1, shape2) {
  if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Line) {
    return relateLine2Line(shape1, shape2);
  } else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Circle) {
    return relateLine2Circle(shape1, shape2);
  } else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Box) {
    return relateLine2Box(shape1, shape2);
  } else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Polygon) {
    return relateLine2Polygon(shape1, shape2);
  } else if ((shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc) && shape2 instanceof Flatten.Polygon) {
    return relateShape2Polygon(shape1, shape2);
  } else if ((shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc) && (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box)) {
    return relateShape2Polygon(shape1, new Flatten.Polygon(shape2));
  } else if (shape1 instanceof Flatten.Polygon && shape2 instanceof Flatten.Polygon) {
    return relatePolygon2Polygon(shape1, shape2);
  } else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) && (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box)) {
    return relatePolygon2Polygon(new Flatten.Polygon(shape1), new Flatten.Polygon(shape2));
  } else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) && shape2 instanceof Flatten.Polygon) {
    return relatePolygon2Polygon(new Flatten.Polygon(shape1), shape2);
  } else if (shape1 instanceof Flatten.Polygon && (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box)) {
    return relatePolygon2Polygon(shape1, new Flatten.Polygon(shape2));
  }
}
function relateLine2Line(line1, line2) {
  let denim = new DE9IM();
  let ip = intersectLine2Line(line1, line2);
  if (ip.length === 0) {
    if (line1.contains(line2.pt) && line2.contains(line1.pt)) {
      denim.I2I = [line1];
      denim.I2E = [];
      denim.E2I = [];
    } else {
      denim.I2I = [];
      denim.I2E = [line1];
      denim.E2I = [line2];
    }
  } else {
    denim.I2I = ip;
    denim.I2E = line1.split(ip);
    denim.E2I = line2.split(ip);
  }
  return denim;
}
function relateLine2Circle(line2, circle2) {
  let denim = new DE9IM();
  let ip = intersectLine2Circle(line2, circle2);
  if (ip.length === 0) {
    denim.I2I = [];
    denim.I2B = [];
    denim.I2E = [line2];
    denim.E2I = [circle2];
  } else if (ip.length === 1) {
    denim.I2I = [];
    denim.I2B = ip;
    denim.I2E = line2.split(ip);
    denim.E2I = [circle2];
  } else {
    let multiline2 = new Multiline$1([line2]);
    let ip_sorted = line2.sortPoints(ip);
    multiline2.split(ip_sorted);
    let splitShapes = multiline2.toShapes();
    denim.I2I = [splitShapes[1]];
    denim.I2B = ip_sorted;
    denim.I2E = [splitShapes[0], splitShapes[2]];
    denim.E2I = new Flatten.Polygon([circle2.toArc()]).cutWithLine(line2);
  }
  return denim;
}
function relateLine2Box(line2, box2) {
  let denim = new DE9IM();
  let ip = intersectLine2Box(line2, box2);
  if (ip.length === 0) {
    denim.I2I = [];
    denim.I2B = [];
    denim.I2E = [line2];
    denim.E2I = [box2];
  } else if (ip.length === 1) {
    denim.I2I = [];
    denim.I2B = ip;
    denim.I2E = line2.split(ip);
    denim.E2I = [box2];
  } else {
    let multiline2 = new Multiline$1([line2]);
    let ip_sorted = line2.sortPoints(ip);
    multiline2.split(ip_sorted);
    let splitShapes = multiline2.toShapes();
    if (box2.toSegments().some((segment2) => segment2.contains(ip[0]) && segment2.contains(ip[1]))) {
      denim.I2I = [];
      denim.I2B = [splitShapes[1]];
      denim.I2E = [splitShapes[0], splitShapes[2]];
      denim.E2I = [box2];
    } else {
      denim.I2I = [splitShapes[1]];
      denim.I2B = ip_sorted;
      denim.I2E = [splitShapes[0], splitShapes[2]];
      denim.E2I = new Flatten.Polygon(box2.toSegments()).cutWithLine(line2);
    }
  }
  return denim;
}
function relateLine2Polygon(line2, polygon2) {
  let denim = new DE9IM();
  let ip = intersectLine2Polygon(line2, polygon2);
  let multiline2 = new Multiline$1([line2]);
  let ip_sorted = ip.length > 0 ? ip.slice() : line2.sortPoints(ip);
  multiline2.split(ip_sorted);
  [...multiline2].forEach((edge) => edge.setInclusion(polygon2));
  denim.I2I = [...multiline2].filter((edge) => edge.bv === Flatten.INSIDE).map((edge) => edge.shape);
  denim.I2B = [...multiline2].slice(1).map((edge) => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start);
  denim.I2E = [...multiline2].filter((edge) => edge.bv === Flatten.OUTSIDE).map((edge) => edge.shape);
  denim.E2I = polygon2.cutWithLine(line2);
  return denim;
}
function relateShape2Polygon(shape, polygon2) {
  let denim = new DE9IM();
  let ip = intersectShape2Polygon(shape, polygon2);
  let ip_sorted = ip.length > 0 ? ip.slice() : shape.sortPoints(ip);
  let multiline2 = new Multiline$1([shape]);
  multiline2.split(ip_sorted);
  [...multiline2].forEach((edge) => edge.setInclusion(polygon2));
  denim.I2I = [...multiline2].filter((edge) => edge.bv === Flatten.INSIDE).map((edge) => edge.shape);
  denim.I2B = [...multiline2].slice(1).map((edge) => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start);
  denim.I2E = [...multiline2].filter((edge) => edge.bv === Flatten.OUTSIDE).map((edge) => edge.shape);
  denim.B2I = [];
  denim.B2B = [];
  denim.B2E = [];
  for (let pt of [shape.start, shape.end]) {
    switch (ray_shoot(polygon2, pt)) {
      case Flatten.INSIDE:
        denim.B2I.push(pt);
        break;
      case Flatten.BOUNDARY:
        denim.B2B.push(pt);
        break;
      case Flatten.OUTSIDE:
        denim.B2E.push(pt);
        break;
    }
  }
  return denim;
}
function relatePolygon2Polygon(polygon1, polygon2) {
  let denim = new DE9IM();
  let [ip_sorted1, ip_sorted2] = calculateIntersections(polygon1, polygon2);
  let boolean_intersection = intersect$1(polygon1, polygon2);
  let boolean_difference1 = subtract(polygon1, polygon2);
  let boolean_difference2 = subtract(polygon2, polygon1);
  let [inner_clip_shapes1, inner_clip_shapes2] = innerClip(polygon1, polygon2);
  let outer_clip_shapes1 = outerClip(polygon1, polygon2);
  let outer_clip_shapes2 = outerClip(polygon2, polygon1);
  denim.I2I = boolean_intersection.isEmpty() ? [] : [boolean_intersection];
  denim.I2B = inner_clip_shapes2;
  denim.I2E = boolean_difference1.isEmpty() ? [] : [boolean_difference1];
  denim.B2I = inner_clip_shapes1;
  denim.B2B = ip_sorted1;
  denim.B2E = outer_clip_shapes1;
  denim.E2I = boolean_difference2.isEmpty() ? [] : [boolean_difference2];
  denim.E2B = outer_clip_shapes2;
  return denim;
}
var Relations = Object.freeze({
  __proto__: null,
  contain,
  cover,
  covered,
  disjoint,
  equal,
  inside,
  intersect,
  relate,
  touch
});
var Matrix = class _Matrix {
  /**
   * Construct new instance of affine transformation matrix <br/>
   * If parameters omitted, construct identity matrix a = 1, d = 1
   * @param {number} a - position(0,0)   sx*cos(alpha)
   * @param {number} b - position (0,1)  sx*sin(alpha)
   * @param {number} c - position (1,0)  -sy*sin(alpha)
   * @param {number} d - position (1,1)  sy*cos(alpha)
   * @param {number} tx - position (2,0) translation by x
   * @param {number} ty - position (2,1) translation by y
   */
  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
  }
  /**
   * Return new cloned instance of matrix
   * @return {Matrix}
   **/
  clone() {
    return new _Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
  }
  /**
   * Transform vector [x,y] using transformation matrix. <br/>
   * Vector [x,y] is an abstract array[2] of numbers and not a FlattenJS object <br/>
   * The result is also an abstract vector [x',y'] = A * [x,y]:
   * <code>
   * [x'       [ ax + by + tx
   *  y'   =     cx + dy + ty
   *  1]                    1 ]
   * </code>
   * @param {number[]} vector - array[2] of numbers
   * @returns {number[]} transformation result - array[2] of numbers
   */
  transform(vector2) {
    return [
      vector2[0] * this.a + vector2[1] * this.c + this.tx,
      vector2[0] * this.b + vector2[1] * this.d + this.ty
    ];
  }
  /**
   * Returns result of multiplication of this matrix by other matrix
   * @param {Matrix} other_matrix - matrix to multiply by
   * @returns {Matrix}
   */
  multiply(other_matrix) {
    return new _Matrix(
      this.a * other_matrix.a + this.c * other_matrix.b,
      this.b * other_matrix.a + this.d * other_matrix.b,
      this.a * other_matrix.c + this.c * other_matrix.d,
      this.b * other_matrix.c + this.d * other_matrix.d,
      this.a * other_matrix.tx + this.c * other_matrix.ty + this.tx,
      this.b * other_matrix.tx + this.d * other_matrix.ty + this.ty
    );
  }
  /**
   * Return new matrix as a result of multiplication of the current matrix
   * by the matrix(1,0,0,1,tx,ty)
   * @param {Vector} vector - Translation by vector or
   * @param {number} tx - translation by x-axis
   * @param {number} ty - translation by y-axis
   * @returns {Matrix}
   */
  translate(...args) {
    let tx, ty;
    if (args.length == 1 && !isNaN(args[0].x) && !isNaN(args[0].y)) {
      tx = args[0].x;
      ty = args[0].y;
    } else if (args.length === 2 && typeof args[0] == "number" && typeof args[1] == "number") {
      tx = args[0];
      ty = args[1];
    } else {
      throw Errors.ILLEGAL_PARAMETERS;
    }
    return this.multiply(new _Matrix(1, 0, 0, 1, tx, ty));
  }
  /**
   * Return new matrix as a result of multiplication of the current matrix
   * by the matrix that defines rotation by given angle (in radians) around
   * center of rotation (centerX,centerY) in counterclockwise direction
   * @param {number} angle - angle in radians
   * @param {number} centerX - center of rotation
   * @param {number} centerY - center of rotation
   * @returns {Matrix}
   */
  rotate(angle, centerX = 0, centerY = 0) {
    let cos = Math.cos(angle);
    let sin = Math.sin(angle);
    return this.translate(centerX, centerY).multiply(new _Matrix(cos, sin, -sin, cos, 0, 0)).translate(-centerX, -centerY);
  }
  /**
   * Return new matrix as a result of multiplication of the current matrix
   * by the matrix (sx,0,0,sy,0,0) that defines scaling
   * @param {number} sx
   * @param {number} sy
   * @returns {Matrix}
   */
  scale(sx, sy) {
    return this.multiply(new _Matrix(sx, 0, 0, sy, 0, 0));
  }
  /**
   * Returns true if two matrix are equal parameter by parameter
   * @param {Matrix} matrix - other matrix
   * @returns {boolean} true if equal, false otherwise
   */
  equalTo(matrix2) {
    if (!Flatten.Utils.EQ(this.tx, matrix2.tx)) return false;
    if (!Flatten.Utils.EQ(this.ty, matrix2.ty)) return false;
    if (!Flatten.Utils.EQ(this.a, matrix2.a)) return false;
    if (!Flatten.Utils.EQ(this.b, matrix2.b)) return false;
    if (!Flatten.Utils.EQ(this.c, matrix2.c)) return false;
    if (!Flatten.Utils.EQ(this.d, matrix2.d)) return false;
    return true;
  }
};
Flatten.Matrix = Matrix;
var matrix = (...args) => new Flatten.Matrix(...args);
Flatten.matrix = matrix;
var Interval = class Interval2 {
  /**
   * Accept two comparable values and creates new instance of interval
   * Predicate Interval.comparable_less(low, high) supposed to return true on these values
   * @param low
   * @param high
   */
  constructor(low, high) {
    this.low = low;
    this.high = high;
  }
  /**
   * Clone interval
   * @returns {Interval}
   */
  clone() {
    return new Interval2(this.low, this.high);
  }
  /**
   * Propery max returns clone of this interval
   * @returns {Interval}
   */
  get max() {
    return this.clone();
  }
  /**
   * Predicate returns true is this interval less than other interval
   * @param other_interval
   * @returns {boolean}
   */
  less_than(other_interval) {
    return this.low < other_interval.low || this.low == other_interval.low && this.high < other_interval.high;
  }
  /**
   * Predicate returns true is this interval equals to other interval
   * @param other_interval
   * @returns {boolean}
   */
  equal_to(other_interval) {
    return this.low == other_interval.low && this.high == other_interval.high;
  }
  /**
   * Predicate returns true if this interval intersects other interval
   * @param other_interval
   * @returns {boolean}
   */
  intersect(other_interval) {
    return !this.not_intersect(other_interval);
  }
  /**
   * Predicate returns true if this interval does not intersect other interval
   * @param other_interval
   * @returns {boolean}
   */
  not_intersect(other_interval) {
    return this.high < other_interval.low || other_interval.high < this.low;
  }
  /**
   * Returns new interval merged with other interval
   * @param {Interval} interval - Other interval to merge with
   * @returns {Interval}
   */
  merge(other_interval) {
    return new Interval2(
      this.low === void 0 ? other_interval.low : Math.min(this.low, other_interval.low),
      this.high === void 0 ? other_interval.high : Math.max(this.high, other_interval.high)
    );
  }
  /**
   * Returns how key should return
   */
  output() {
    return [this.low, this.high];
  }
  /**
   * Function returns maximum between two comparable values
   * @param interval1
   * @param interval2
   * @returns {Interval}
   */
  static comparable_max(interval1, interval2) {
    return interval1.merge(interval2);
  }
  /**
   * Predicate returns true if first value less than second value
   * @param val1
   * @param val2
   * @returns {boolean}
   */
  static comparable_less_than(val1, val2) {
    return val1 < val2;
  }
};
var RB_TREE_COLOR_RED = 0;
var RB_TREE_COLOR_BLACK = 1;
var Node = class {
  constructor(key = void 0, value = void 0, left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {
    this.left = left;
    this.right = right;
    this.parent = parent;
    this.color = color;
    this.item = { key, value };
    if (key && key instanceof Array && key.length == 2) {
      if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {
        this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));
      }
    }
    this.max = this.item.key ? this.item.key.max : void 0;
  }
  isNil() {
    return this.item.key === void 0 && this.item.value === void 0 && this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK;
  }
  _value_less_than(other_node) {
    return this.item.value && other_node.item.value && this.item.value.less_than ? this.item.value.less_than(other_node.item.value) : this.item.value < other_node.item.value;
  }
  less_than(other_node) {
    if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {
      return this.item.key.less_than(other_node.item.key);
    } else {
      return this.item.key.less_than(other_node.item.key) || this.item.key.equal_to(other_node.item.key) && this._value_less_than(other_node);
    }
  }
  _value_equal(other_node) {
    return this.item.value && other_node.item.value && this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) : this.item.value == other_node.item.value;
  }
  equal_to(other_node) {
    if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {
      return this.item.key.equal_to(other_node.item.key);
    } else {
      return this.item.key.equal_to(other_node.item.key) && this._value_equal(other_node);
    }
  }
  intersect(other_node) {
    return this.item.key.intersect(other_node.item.key);
  }
  copy_data(other_node) {
    this.item.key = other_node.item.key;
    this.item.value = other_node.item.value;
  }
  update_max() {
    this.max = this.item.key ? this.item.key.max : void 0;
    if (this.right && this.right.max) {
      const comparable_max = this.item.key.constructor.comparable_max;
      this.max = comparable_max(this.max, this.right.max);
    }
    if (this.left && this.left.max) {
      const comparable_max = this.item.key.constructor.comparable_max;
      this.max = comparable_max(this.max, this.left.max);
    }
  }
  // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low
  not_intersect_left_subtree(search_node) {
    const comparable_less_than = this.item.key.constructor.comparable_less_than;
    let high = this.left.max.high !== void 0 ? this.left.max.high : this.left.max;
    return comparable_less_than(high, search_node.item.key.low);
  }
  // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low
  not_intersect_right_subtree(search_node) {
    const comparable_less_than = this.item.key.constructor.comparable_less_than;
    let low = this.right.max.low !== void 0 ? this.right.max.low : this.right.item.key.low;
    return comparable_less_than(search_node.item.key.high, low);
  }
};
var IntervalTree = class _IntervalTree {
  /**
   * Construct new empty instance of IntervalTree
   */
  constructor() {
    this.root = null;
    this.nil_node = new Node();
  }
  /**
   * Returns number of items stored in the interval tree
   * @returns {number}
   */
  get size() {
    let count = 0;
    this.tree_walk(this.root, () => count++);
    return count;
  }
  /**
   * Returns array of sorted keys in the ascending order
   * @returns {Array}
   */
  get keys() {
    let res = [];
    this.tree_walk(this.root, (node) => res.push(
      node.item.key.output ? node.item.key.output() : node.item.key
    ));
    return res;
  }
  /**
   * Return array of values in the ascending keys order
   * @returns {Array}
   */
  get values() {
    let res = [];
    this.tree_walk(this.root, (node) => res.push(node.item.value));
    return res;
  }
  /**
   * Returns array of items (<key,value> pairs) in the ascended keys order
   * @returns {Array}
   */
  get items() {
    let res = [];
    this.tree_walk(this.root, (node) => res.push({
      key: node.item.key.output ? node.item.key.output() : node.item.key,
      value: node.item.value
    }));
    return res;
  }
  /**
   * Returns true if tree is empty
   * @returns {boolean}
   */
  isEmpty() {
    return this.root == null || this.root == this.nil_node;
  }
  /**
   * Clear tree
   */
  clear() {
    this.root = null;
  }
  /**
   * Insert new item into interval tree
   * @param {Interval} key - interval object or array of two numbers [low, high]
   * @param {any} value - value representing any object (optional)
   * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}
   */
  insert(key, value = key) {
    if (key === void 0) return;
    let insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);
    this.tree_insert(insert_node);
    this.recalc_max(insert_node);
    return insert_node;
  }
  /**
   * Returns true if item {key,value} exist in the tree
   * @param {Interval} key - interval correspondent to keys stored in the tree
   * @param {any} value - value object to be checked
   * @returns {boolean} true if item {key, value} exist in the tree, false otherwise
   */
  exist(key, value = key) {
    let search_node = new Node(key, value);
    return this.tree_search(this.root, search_node) ? true : false;
  }
  /**
   * Remove entry {key, value} from the tree
   * @param {Interval} key - interval correspondent to keys stored in the tree
   * @param {any} value - value object
   * @returns {boolean} true if item {key, value} deleted, false if not found
   */
  remove(key, value = key) {
    let search_node = new Node(key, value);
    let delete_node = this.tree_search(this.root, search_node);
    if (delete_node) {
      this.tree_delete(delete_node);
    }
    return delete_node;
  }
  /**
   * Returns array of entry values which keys intersect with given interval <br/>
   * If no values stored in the tree, returns array of keys which intersect given interval
   * @param {Interval} interval - search interval, or tuple [low, high]
   * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output
   * @returns {Array}
   */
  search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {
    let search_node = new Node(interval);
    let resp_nodes = [];
    this.tree_search_interval(this.root, search_node, resp_nodes);
    return resp_nodes.map((node) => outputMapperFn(node.item.value, node.item.key));
  }
  /**
   * Returns true if intersection between given and any interval stored in the tree found
   * @param {Interval} interval - search interval or tuple [low, high]
   * @returns {boolean}
   */
  intersect_any(interval) {
    let search_node = new Node(interval);
    let found = this.tree_find_any_interval(this.root, search_node);
    return found;
  }
  /**
   * Tree visitor. For each node implement a callback function. <br/>
   * Method calls a callback function with two parameters (key, value)
   * @param visitor(key,value) - function to be called for each tree item
   */
  forEach(visitor) {
    this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));
  }
  /** Value Mapper. Walk through every node and map node value to another value
  * @param callback(value,key) - function to be called for each tree item
  */
  map(callback) {
    const tree = new _IntervalTree();
    this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));
    return tree;
  }
  recalc_max(node) {
    let node_current = node;
    while (node_current.parent != null) {
      node_current.parent.update_max();
      node_current = node_current.parent;
    }
  }
  tree_insert(insert_node) {
    let current_node = this.root;
    let parent_node = null;
    if (this.root == null || this.root == this.nil_node) {
      this.root = insert_node;
    } else {
      while (current_node != this.nil_node) {
        parent_node = current_node;
        if (insert_node.less_than(current_node)) {
          current_node = current_node.left;
        } else {
          current_node = current_node.right;
        }
      }
      insert_node.parent = parent_node;
      if (insert_node.less_than(parent_node)) {
        parent_node.left = insert_node;
      } else {
        parent_node.right = insert_node;
      }
    }
    this.insert_fixup(insert_node);
  }
  // After insertion insert_node may have red-colored parent, and this is a single possible violation
  // Go upwords to the root and re-color until violation will be resolved
  insert_fixup(insert_node) {
    let current_node;
    let uncle_node;
    current_node = insert_node;
    while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {
      if (current_node.parent == current_node.parent.parent.left) {
        uncle_node = current_node.parent.parent.right;
        if (uncle_node.color == RB_TREE_COLOR_RED) {
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          uncle_node.color = RB_TREE_COLOR_BLACK;
          current_node.parent.parent.color = RB_TREE_COLOR_RED;
          current_node = current_node.parent.parent;
        } else {
          if (current_node == current_node.parent.right) {
            current_node = current_node.parent;
            this.rotate_left(current_node);
          }
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          current_node.parent.parent.color = RB_TREE_COLOR_RED;
          this.rotate_right(current_node.parent.parent);
        }
      } else {
        uncle_node = current_node.parent.parent.left;
        if (uncle_node.color == RB_TREE_COLOR_RED) {
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          uncle_node.color = RB_TREE_COLOR_BLACK;
          current_node.parent.parent.color = RB_TREE_COLOR_RED;
          current_node = current_node.parent.parent;
        } else {
          if (current_node == current_node.parent.left) {
            current_node = current_node.parent;
            this.rotate_right(current_node);
          }
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          current_node.parent.parent.color = RB_TREE_COLOR_RED;
          this.rotate_left(current_node.parent.parent);
        }
      }
    }
    this.root.color = RB_TREE_COLOR_BLACK;
  }
  tree_delete(delete_node) {
    let cut_node;
    let fix_node;
    if (delete_node.left == this.nil_node || delete_node.right == this.nil_node) {
      cut_node = delete_node;
    } else {
      cut_node = this.tree_successor(delete_node);
    }
    if (cut_node.left != this.nil_node) {
      fix_node = cut_node.left;
    } else {
      fix_node = cut_node.right;
    }
    fix_node.parent = cut_node.parent;
    if (cut_node == this.root) {
      this.root = fix_node;
    } else {
      if (cut_node == cut_node.parent.left) {
        cut_node.parent.left = fix_node;
      } else {
        cut_node.parent.right = fix_node;
      }
      cut_node.parent.update_max();
    }
    this.recalc_max(fix_node);
    if (cut_node != delete_node) {
      delete_node.copy_data(cut_node);
      delete_node.update_max();
      this.recalc_max(delete_node);
    }
    if (
      /*fix_node != this.nil_node && */
      cut_node.color == RB_TREE_COLOR_BLACK
    ) {
      this.delete_fixup(fix_node);
    }
  }
  delete_fixup(fix_node) {
    let current_node = fix_node;
    let brother_node;
    while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {
      if (current_node == current_node.parent.left) {
        brother_node = current_node.parent.right;
        if (brother_node.color == RB_TREE_COLOR_RED) {
          brother_node.color = RB_TREE_COLOR_BLACK;
          current_node.parent.color = RB_TREE_COLOR_RED;
          this.rotate_left(current_node.parent);
          brother_node = current_node.parent.right;
        }
        if (brother_node.left.color == RB_TREE_COLOR_BLACK && brother_node.right.color == RB_TREE_COLOR_BLACK) {
          brother_node.color = RB_TREE_COLOR_RED;
          current_node = current_node.parent;
        } else {
          if (brother_node.right.color == RB_TREE_COLOR_BLACK) {
            brother_node.color = RB_TREE_COLOR_RED;
            brother_node.left.color = RB_TREE_COLOR_BLACK;
            this.rotate_right(brother_node);
            brother_node = current_node.parent.right;
          }
          brother_node.color = current_node.parent.color;
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          brother_node.right.color = RB_TREE_COLOR_BLACK;
          this.rotate_left(current_node.parent);
          current_node = this.root;
        }
      } else {
        brother_node = current_node.parent.left;
        if (brother_node.color == RB_TREE_COLOR_RED) {
          brother_node.color = RB_TREE_COLOR_BLACK;
          current_node.parent.color = RB_TREE_COLOR_RED;
          this.rotate_right(current_node.parent);
          brother_node = current_node.parent.left;
        }
        if (brother_node.left.color == RB_TREE_COLOR_BLACK && brother_node.right.color == RB_TREE_COLOR_BLACK) {
          brother_node.color = RB_TREE_COLOR_RED;
          current_node = current_node.parent;
        } else {
          if (brother_node.left.color == RB_TREE_COLOR_BLACK) {
            brother_node.color = RB_TREE_COLOR_RED;
            brother_node.right.color = RB_TREE_COLOR_BLACK;
            this.rotate_left(brother_node);
            brother_node = current_node.parent.left;
          }
          brother_node.color = current_node.parent.color;
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          brother_node.left.color = RB_TREE_COLOR_BLACK;
          this.rotate_right(current_node.parent);
          current_node = this.root;
        }
      }
    }
    current_node.color = RB_TREE_COLOR_BLACK;
  }
  tree_search(node, search_node) {
    if (node == null || node == this.nil_node)
      return void 0;
    if (search_node.equal_to(node)) {
      return node;
    }
    if (search_node.less_than(node)) {
      return this.tree_search(node.left, search_node);
    } else {
      return this.tree_search(node.right, search_node);
    }
  }
  // Original search_interval method; container res support push() insertion
  // Search all intervals intersecting given one
  tree_search_interval(node, search_node, res) {
    if (node != null && node != this.nil_node) {
      if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {
        this.tree_search_interval(node.left, search_node, res);
      }
      if (node.intersect(search_node)) {
        res.push(node);
      }
      if (node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {
        this.tree_search_interval(node.right, search_node, res);
      }
    }
  }
  tree_find_any_interval(node, search_node) {
    let found = false;
    if (node != null && node != this.nil_node) {
      if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {
        found = this.tree_find_any_interval(node.left, search_node);
      }
      if (!found) {
        found = node.intersect(search_node);
      }
      if (!found && node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {
        found = this.tree_find_any_interval(node.right, search_node);
      }
    }
    return found;
  }
  local_minimum(node) {
    let node_min = node;
    while (node_min.left != null && node_min.left != this.nil_node) {
      node_min = node_min.left;
    }
    return node_min;
  }
  // not in use
  local_maximum(node) {
    let node_max = node;
    while (node_max.right != null && node_max.right != this.nil_node) {
      node_max = node_max.right;
    }
    return node_max;
  }
  tree_successor(node) {
    let node_successor;
    let current_node;
    let parent_node;
    if (node.right != this.nil_node) {
      node_successor = this.local_minimum(node.right);
    } else {
      current_node = node;
      parent_node = node.parent;
      while (parent_node != null && parent_node.right == current_node) {
        current_node = parent_node;
        parent_node = parent_node.parent;
      }
      node_successor = parent_node;
    }
    return node_successor;
  }
  //           |            right-rotate(T,y)       |
  //           y            ---------------.       x
  //          / \                                  / \
  //         x   c          left-rotate(T,x)      a   y
  //        / \             <---------------         / \
  //       a   b                                    b   c
  rotate_left(x) {
    let y = x.right;
    x.right = y.left;
    if (y.left != this.nil_node) {
      y.left.parent = x;
    }
    y.parent = x.parent;
    if (x == this.root) {
      this.root = y;
    } else {
      if (x == x.parent.left) {
        x.parent.left = y;
      } else {
        x.parent.right = y;
      }
    }
    y.left = x;
    x.parent = y;
    if (x != null && x != this.nil_node) {
      x.update_max();
    }
    y = x.parent;
    if (y != null && y != this.nil_node) {
      y.update_max();
    }
  }
  rotate_right(y) {
    let x = y.left;
    y.left = x.right;
    if (x.right != this.nil_node) {
      x.right.parent = y;
    }
    x.parent = y.parent;
    if (y == this.root) {
      this.root = x;
    } else {
      if (y == y.parent.left) {
        y.parent.left = x;
      } else {
        y.parent.right = x;
      }
    }
    x.right = y;
    y.parent = x;
    if (y != null && y != this.nil_node) {
      y.update_max();
    }
    x = y.parent;
    if (x != null && x != this.nil_node) {
      x.update_max();
    }
  }
  tree_walk(node, action) {
    if (node != null && node != this.nil_node) {
      this.tree_walk(node.left, action);
      action(node);
      this.tree_walk(node.right, action);
    }
  }
  /* Return true if all red nodes have exactly two black child nodes */
  testRedBlackProperty() {
    let res = true;
    this.tree_walk(this.root, function(node) {
      if (node.color == RB_TREE_COLOR_RED) {
        if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {
          res = false;
        }
      }
    });
    return res;
  }
  /* Throw error if not every path from root to bottom has same black height */
  testBlackHeightProperty(node) {
    let height = 0;
    let heightLeft = 0;
    let heightRight = 0;
    if (node.color == RB_TREE_COLOR_BLACK) {
      height++;
    }
    if (node.left != this.nil_node) {
      heightLeft = this.testBlackHeightProperty(node.left);
    } else {
      heightLeft = 1;
    }
    if (node.right != this.nil_node) {
      heightRight = this.testBlackHeightProperty(node.right);
    } else {
      heightRight = 1;
    }
    if (heightLeft != heightRight) {
      throw new Error("Red-black height property violated");
    }
    height += heightLeft;
    return height;
  }
};
var PlanarSet = class extends Set {
  /**
   * Create new instance of PlanarSet
   * @param shapes - array or set of geometric objects to store in planar set
   * Each object should have a <b>box</b> property
   */
  constructor(shapes) {
    super(shapes);
    this.index = new IntervalTree();
    this.forEach((shape) => this.index.insert(shape));
  }
  /**
   * Add new shape to planar set and to its spatial index.<br/>
   * If shape already exist, it will not be added again.
   * This happens with no error, it is possible to use <i>size</i> property to check if
   * a shape was actually added.<br/>
   * Method returns planar set object updated and may be chained
   * @param {AnyShape | {Box, AnyShape}} entry - shape to be added, should have valid <i>box</i> property
   * Another option to transfer as an object {key: Box, value: AnyShape}
   * @returns {PlanarSet}
   */
  add(entry) {
    let size = this.size;
    const { key, value } = entry;
    const box2 = key || entry.box;
    const shape = value || entry;
    super.add(shape);
    if (this.size > size) {
      this.index.insert(box2, shape);
    }
    return this;
  }
  /**
   * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise
   * @param {AnyShape | {Box, AnyShape}} entry - shape to be deleted
   * @returns {boolean}
   */
  delete(entry) {
    const { key, value } = entry;
    const box2 = key || entry.box;
    const shape = value || entry;
    let deleted = super.delete(shape);
    if (deleted) {
      this.index.remove(box2, shape);
    }
    return deleted;
  }
  /**
   * Clear planar set
   */
  clear() {
    super.clear();
    this.index = new IntervalTree();
  }
  /**
   * 2d range search in planar set.<br/>
   * Returns array of all shapes in planar set which bounding box is intersected with query box
   * @param {Box} box - query box
   * @returns {AnyShape[]}
   */
  search(box2) {
    let resp = this.index.search(box2);
    return resp;
  }
  /**
   * Point location test. Returns array of shapes which contains given point
   * @param {Point} point - query point
   * @returns {AnyShape[]}
   */
  hit(point2) {
    let box2 = new Flatten.Box(point2.x - 1, point2.y - 1, point2.x + 1, point2.y + 1);
    let resp = this.index.search(box2);
    return resp.filter((shape) => point2.on(shape));
  }
  /**
   * Returns svg string to draw all shapes in planar set
   * @returns {String}
   */
  svg() {
    let svgcontent = [...this].reduce((acc, shape) => acc + shape.svg(), "");
    return svgcontent;
  }
};
Flatten.PlanarSet = PlanarSet;
var Shape = class {
  get name() {
    throw Errors.CANNOT_INVOKE_ABSTRACT_METHOD;
  }
  get box() {
    throw Errors.CANNOT_INVOKE_ABSTRACT_METHOD;
  }
  clone() {
    throw Errors.CANNOT_INVOKE_ABSTRACT_METHOD;
  }
  /**
   * Returns new shape translated by given vector.
   * Translation vector may be also defined by a pair of numbers.
   * @param {Vector | (number, number) } args - Translation vector
   * or tuple of numbers
   * @returns {Shape}
   */
  translate(...args) {
    return this.transform(new Matrix().translate(...args));
  }
  /**
   * Returns new shape rotated by given angle around given center point.
   * If center point is omitted, rotates around zero point (0,0).
   * Positive value of angle defines rotation in counterclockwise direction,
   * negative angle defines rotation in clockwise direction
   * @param {number} angle - angle in radians
   * @param {Point} [center=(0,0)] center
   * @returns {Shape}
   */
  rotate(angle, center = new Flatten.Point()) {
    return this.transform(new Matrix().rotate(angle, center.x, center.y));
  }
  /**
   * Return new shape with coordinates multiplied by scaling factor
   * @param {number} sx - x-axis scaling factor
   * @param {number} sy - y-axis scaling factor
   * @returns {Shape}
   */
  scale(sx, sy) {
    return this.transform(new Matrix().scale(sx, sy));
  }
  transform(...args) {
    throw Errors.CANNOT_INVOKE_ABSTRACT_METHOD;
  }
  /**
   * This method returns an object that defines how data will be
   * serialized when called JSON.stringify() method
   * @returns {Object}
   */
  toJSON() {
    return Object.assign({}, this, { name: this.name });
  }
  svg(attrs = {}) {
    throw Errors.CANNOT_INVOKE_ABSTRACT_METHOD;
  }
};
var Point$3 = class Point2 extends Shape {
  /**
   * Point may be constructed by two numbers, or by array of two numbers
   * @param {number} x - x-coordinate (float number)
   * @param {number} y - y-coordinate (float number)
   */
  constructor(...args) {
    super();
    this.x = 0;
    this.y = 0;
    if (args.length === 0) {
      return;
    }
    if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {
      let arr = args[0];
      if (typeof arr[0] == "number" && typeof arr[1] == "number") {
        this.x = arr[0];
        this.y = arr[1];
        return;
      }
    }
    if (args.length === 1 && args[0] instanceof Object && args[0].name === "point") {
      let { x, y } = args[0];
      this.x = x;
      this.y = y;
      return;
    }
    if (args.length === 2) {
      if (typeof args[0] == "number" && typeof args[1] == "number") {
        this.x = args[0];
        this.y = args[1];
        return;
      }
    }
    throw Errors.ILLEGAL_PARAMETERS;
  }
  /**
   * Returns bounding box of a point
   * @returns {Box}
   */
  get box() {
    return new Flatten.Box(this.x, this.y, this.x, this.y);
  }
  /**
   * Return new cloned instance of point
   * @returns {Point}
   */
  clone() {
    return new Flatten.Point(this.x, this.y);
  }
  get vertices() {
    return [this.clone()];
  }
  /**
   * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance
   * @param {Point} pt Query point
   * @returns {boolean}
   */
  equalTo(pt) {
    return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);
  }
  /**
   * Defines predicate "less than" between points. Returns true if the point is less than query points, false otherwise <br/>
   * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.x <br/>
   * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance
   * @param {Point} pt Query point
   * @returns {boolean}
   */
  lessThan(pt) {
    if (Flatten.Utils.LT(this.y, pt.y))
      return true;
    if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x))
      return true;
    return false;
  }
  /**
   * Return new point transformed by affine transformation matrix
   * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)
   * @returns {Point}
   */
  transform(m) {
    return new Flatten.Point(m.transform([this.x, this.y]));
  }
  /**
   * Returns projection point on given line
   * @param {Line} line Line this point be projected on
   * @returns {Point}
   */
  projectionOn(line2) {
    if (this.equalTo(line2.pt))
      return this.clone();
    let vec = new Flatten.Vector(this, line2.pt);
    if (Flatten.Utils.EQ_0(vec.cross(line2.norm)))
      return line2.pt.clone();
    let dist = vec.dot(line2.norm);
    let proj_vec = line2.norm.multiply(dist);
    return this.translate(proj_vec);
  }
  /**
   * Returns true if point belongs to the "left" semi-plane, which means, point belongs to the same semi plane where line normal vector points to
   * Return false if point belongs to the "right" semi-plane or to the line itself
   * @param {Line} line Query line
   * @returns {boolean}
   */
  leftTo(line2) {
    let vec = new Flatten.Vector(line2.pt, this);
    let onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line2.norm), 0);
    return onLeftSemiPlane;
  }
  /**
   * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]
   * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set
   * @returns {number} distance from point to shape
   * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)
   */
  distanceTo(shape) {
    if (shape instanceof Point2) {
      let dx = shape.x - this.x;
      let dy = shape.y - this.y;
      return [Math.sqrt(dx * dx + dy * dy), new Flatten.Segment(this, shape)];
    }
    if (shape instanceof Flatten.Line) {
      return Flatten.Distance.point2line(this, shape);
    }
    if (shape instanceof Flatten.Circle) {
      return Flatten.Distance.point2circle(this, shape);
    }
    if (shape instanceof Flatten.Segment) {
      return Flatten.Distance.point2segment(this, shape);
    }
    if (shape instanceof Flatten.Arc) {
      return Flatten.Distance.point2arc(this, shape);
    }
    if (shape instanceof Flatten.Polygon) {
      return Flatten.Distance.point2polygon(this, shape);
    }
    if (shape instanceof Flatten.PlanarSet) {
      return Flatten.Distance.shape2planarSet(this, shape);
    }
    if (shape instanceof Flatten.Multiline) {
      return Flatten.Distance.shape2multiline(this, shape);
    }
  }
  /**
   * Returns true if point is on a shape, false otherwise
   * @param {Shape} shape
   * @returns {boolean}
   */
  on(shape) {
    if (shape instanceof Flatten.Point) {
      return this.equalTo(shape);
    }
    if (shape.contains && shape.contains instanceof Function) {
      return shape.contains(this);
    }
    throw Flatten.Errors.UNSUPPORTED_SHAPE_TYPE;
  }
  get name() {
    return "point";
  }
  /**
   * Return string to draw point in svg as circle with radius "r" <br/>
   * Accept any valid attributes of svg elements as svg object
   * Defaults attribues are: <br/>
   * {
   *    r:"3",
   *    stroke:"black",
   *    strokeWidth:"1",
   *    fill:"red"
   * }
   * @param {Object} attrs - Any valid attributes of svg circle element, like "r", "stroke", "strokeWidth", "fill"
   * @returns {String}
   */
  svg(attrs = {}) {
    const r = attrs.r ?? 3;
    return `
<circle cx="${this.x}" cy="${this.y}" r="${r}"
            ${convertToString({ fill: "red", ...attrs })} />`;
  }
};
Flatten.Point = Point$3;
var point = (...args) => new Flatten.Point(...args);
Flatten.point = point;
var Vector$1 = class Vector extends Shape {
  /**
   * Vector may be constructed by two points, or by two float numbers,
   * or by array of two numbers
   * @param {Point} ps - start point
   * @param {Point} pe - end point
   */
  constructor(...args) {
    super();
    this.x = 0;
    this.y = 0;
    if (args.length === 0) {
      return;
    }
    if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {
      let arr = args[0];
      if (typeof arr[0] == "number" && typeof arr[1] == "number") {
        this.x = arr[0];
        this.y = arr[1];
        return;
      }
    }
    if (args.length === 1 && args[0] instanceof Object && args[0].name === "vector") {
      let { x, y } = args[0];
      this.x = x;
      this.y = y;
      return;
    }
    if (args.length === 2) {
      let a1 = args[0];
      let a2 = args[1];
      if (typeof a1 == "number" && typeof a2 == "number") {
        this.x = a1;
        this.y = a2;
        return;
      }
      if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {
        this.x = a2.x - a1.x;
        this.y = a2.y - a1.y;
        return;
      }
    }
    throw Errors.ILLEGAL_PARAMETERS;
  }
  /**
   * Method clone returns new instance of Vector
   * @returns {Vector}
   */
  clone() {
    return new Flatten.Vector(this.x, this.y);
  }
  /**
   * Slope of the vector in radians from 0 to 2PI
   * @returns {number}
   */
  get slope() {
    let angle = Math.atan2(this.y, this.x);
    if (angle < 0) angle = 2 * Math.PI + angle;
    return angle;
  }
  /**
   * Length of vector
   * @returns {number}
   */
  get length() {
    return Math.sqrt(this.dot(this));
  }
  /**
   * Returns true if vectors are equal up to [DP_TOL]{@link http://localhost:63342/flatten-js/docs/global.html#DP_TOL}
   * tolerance
   * @param {Vector} v
   * @returns {boolean}
   */
  equalTo(v) {
    return Flatten.Utils.EQ(this.x, v.x) && Flatten.Utils.EQ(this.y, v.y);
  }
  /**
   * Returns new vector multiplied by scalar
   * @param {number} scalar
   * @returns {Vector}
   */
  multiply(scalar) {
    return new Flatten.Vector(scalar * this.x, scalar * this.y);
  }
  /**
   * Returns scalar product (dot product) of two vectors <br/>
   * <code>dot_product = (this * v)</code>
   * @param {Vector} v Other vector
   * @returns {number}
   */
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  /**
   * Returns vector product (cross product) of two vectors <br/>
   * <code>cross_product = (this x v)</code>
   * @param {Vector} v Other vector
   * @returns {number}
   */
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  /**
   * Returns unit vector.<br/>
   * Throw error if given vector has zero length
   * @returns {Vector}
   */
  normalize() {
    if (!Flatten.Utils.EQ_0(this.length)) {
      return new Flatten.Vector(this.x / this.length, this.y / this.length);
    }
    throw Errors.ZERO_DIVISION;
  }
  /**
   * Returns new vector rotated by given angle,
   * positive angle defines rotation in counterclockwise direction,
   * negative - in clockwise direction
   * Vector only can be rotated around (0,0) point!
   * @param {number} angle - Angle in radians
   * @returns {Vector}
   */
  rotate(angle, center = new Flatten.Point()) {
    if (center.x === 0 && center.y === 0) {
      return this.transform(new Matrix().rotate(angle));
    }
    throw Errors.OPERATION_IS_NOT_SUPPORTED;
  }
  /**
   * Return new vector transformed by affine transformation matrix m
   * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)
   * @returns {Vector}
   */
  transform(m) {
    return new Flatten.Vector(m.transform([this.x, this.y]));
  }
  /**
   * Returns vector rotated 90 degrees counterclockwise
   * @returns {Vector}
   */
  rotate90CCW() {
    return new Flatten.Vector(-this.y, this.x);
  }
  /**
   * Returns vector rotated 90 degrees clockwise
   * @returns {Vector}
   */
  rotate90CW() {
    return new Flatten.Vector(this.y, -this.x);
  }
  /**
   * Return inverted vector
   * @returns {Vector}
   */
  invert() {
    return new Flatten.Vector(-this.x, -this.y);
  }
  /**
   * Return result of addition of other vector to this vector as a new vector
   * @param {Vector} v Other vector
   * @returns {Vector}
   */
  add(v) {
    return new Flatten.Vector(this.x + v.x, this.y + v.y);
  }
  /**
   * Return result of subtraction of other vector from current vector as a new vector
   * @param {Vector} v Another vector
   * @returns {Vector}
   */
  subtract(v) {
    return new Flatten.Vector(this.x - v.x, this.y - v.y);
  }
  /**
   * Return angle between this vector and other vector. <br/>
   * Angle is measured from 0 to 2*PI in the counterclockwise direction
   * from current vector to  another.
   * @param {Vector} v Another vector
   * @returns {number}
   */
  angleTo(v) {
    let norm1 = this.normalize();
    let norm2 = v.normalize();
    let angle = Math.atan2(norm1.cross(norm2), norm1.dot(norm2));
    if (angle < 0) angle += 2 * Math.PI;
    return angle;
  }
  /**
   * Return vector projection of the current vector on another vector
   * @param {Vector} v Another vector
   * @returns {Vector}
   */
  projectionOn(v) {
    let n = v.normalize();
    let d = this.dot(n);
    return n.multiply(d);
  }
  get name() {
    return "vector";
  }
};
Flatten.Vector = Vector$1;
var vector$1 = (...args) => new Flatten.Vector(...args);
Flatten.vector = vector$1;
var Segment$1 = class Segment extends Shape {
  /**
   *
   * @param {Point} ps - start point
   * @param {Point} pe - end point
   */
  constructor(...args) {
    super();
    this.ps = new Flatten.Point();
    this.pe = new Flatten.Point();
    if (args.length === 0) {
      return;
    }
    if (args.length === 1 && args[0] instanceof Array && args[0].length === 4) {
      let coords = args[0];
      this.ps = new Flatten.Point(coords[0], coords[1]);
      this.pe = new Flatten.Point(coords[2], coords[3]);
      return;
    }
    if (args.length === 1 && args[0] instanceof Object && args[0].name === "segment") {
      let { ps, pe } = args[0];
      this.ps = new Flatten.Point(ps.x, ps.y);
      this.pe = new Flatten.Point(pe.x, pe.y);
      return;
    }
    if (args.length === 1 && args[0] instanceof Flatten.Point) {
      this.ps = args[0].clone();
      return;
    }
    if (args.length === 2 && args[0] instanceof Flatten.Point && args[1] instanceof Flatten.Point) {
      this.ps = args[0].clone();
      this.pe = args[1].clone();
      return;
    }
    if (args.length === 4) {
      this.ps = new Flatten.Point(args[0], args[1]);
      this.pe = new Flatten.Point(args[2], args[3]);
      return;
    }
    throw Errors.ILLEGAL_PARAMETERS;
  }
  /**
   * Return new cloned instance of segment
   * @returns {Segment}
   */
  clone() {
    return new Flatten.Segment(this.start, this.end);
  }
  /**
   * Start point
   * @returns {Point}
   */
  get start() {
    return this.ps;
  }
  /**
   * End point
   * @returns {Point}
   */
  get end() {
    return this.pe;
  }
  /**
   * Returns array of start and end point
   * @returns [Point,Point]
   */
  get vertices() {
    return [this.ps.clone(), this.pe.clone()];
  }
  /**
   * Length of a segment
   * @returns {number}
   */
  get length() {
    return this.start.distanceTo(this.end)[0];
  }
  /**
   * Slope of the line - angle to axe x in radians from 0 to 2PI
   * @returns {number}
   */
  get slope() {
    let vec = new Flatten.Vector(this.start, this.end);
    return vec.slope;
  }
  /**
   * Bounding box
   * @returns {Box}
   */
  get box() {
    return new Flatten.Box(
      Math.min(this.start.x, this.end.x),
      Math.min(this.start.y, this.end.y),
      Math.max(this.start.x, this.end.x),
      Math.max(this.start.y, this.end.y)
    );
  }
  /**
   * Returns true if equals to query segment, false otherwise
   * @param {Segment} seg - query segment
   * @returns {boolean}
   */
  equalTo(seg) {
    return this.ps.equalTo(seg.ps) && this.pe.equalTo(seg.pe);
  }
  /**
   * Returns true if segment contains point
   * @param {Point} pt Query point
   * @returns {boolean}
   */
  contains(pt) {
    return Flatten.Utils.EQ_0(this.distanceToPoint(pt));
  }
  /**
   * Returns array of intersection points between segment and other shape
   * @param {Shape} shape - Shape of the one of supported types <br/>
   * @returns {Point[]}
   */
  intersect(shape) {
    if (shape instanceof Flatten.Point) {
      return this.contains(shape) ? [shape] : [];
    }
    if (shape instanceof Flatten.Line) {
      return intersectSegment2Line(this, shape);
    }
    if (shape instanceof Flatten.Ray) {
      return intersectRay2Segment(shape, this);
    }
    if (shape instanceof Flatten.Segment) {
      return intersectSegment2Segment(this, shape);
    }
    if (shape instanceof Flatten.Circle) {
      return intersectSegment2Circle(this, shape);
    }
    if (shape instanceof Flatten.Box) {
      return intersectSegment2Box(this, shape);
    }
    if (shape instanceof Flatten.Arc) {
      return intersectSegment2Arc(this, shape);
    }
    if (shape instanceof Flatten.Polygon) {
      return intersectSegment2Polygon(this, shape);
    }
    if (shape instanceof Flatten.Multiline) {
      return intersectShape2Multiline(this, shape);
    }
  }
  /**
   * Calculate distance and shortest segment from segment to shape and return as array [distance, shortest segment]
   * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set
   * @returns {[number, Segment]} shortest segment between segment and shape (started at segment, ended at shape)
   */
  distanceTo(shape) {
    if (shape instanceof Flatten.Point) {
      let [dist, shortest_segment] = Flatten.Distance.point2segment(shape, this);
      shortest_segment = shortest_segment.reverse();
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.Circle) {
      let [dist, shortest_segment] = Flatten.Distance.segment2circle(this, shape);
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.Line) {
      let [dist, shortest_segment] = Flatten.Distance.segment2line(this, shape);
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.Segment) {
      let [dist, shortest_segment] = Flatten.Distance.segment2segment(this, shape);
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.Arc) {
      let [dist, shortest_segment] = Flatten.Distance.segment2arc(this, shape);
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.Polygon) {
      let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.PlanarSet) {
      let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.Multiline) {
      return Flatten.Distance.shape2multiline(this, shape);
    }
  }
  /**
   * Returns unit vector in the direction from start to end
   * @returns {Vector}
   */
  tangentInStart() {
    let vec = new Flatten.Vector(this.start, this.end);
    return vec.normalize();
  }
  /**
   * Return unit vector in the direction from end to start
   * @returns {Vector}
   */
  tangentInEnd() {
    let vec = new Flatten.Vector(this.end, this.start);
    return vec.normalize();
  }
  /**
   * Returns new segment with swapped start and end points
   * @returns {Segment}
   */
  reverse() {
    return new Segment(this.end, this.start);
  }
  /**
   * When point belongs to segment, return array of two segments split by given point,
   * if point is inside segment. Returns clone of this segment if query point is incident
   * to start or end point of the segment. Returns empty array if point does not belong to segment
   * @param {Point} pt Query point
   * @returns {Segment[]}
   */
  split(pt) {
    if (this.start.equalTo(pt))
      return [null, this.clone()];
    if (this.end.equalTo(pt))
      return [this.clone(), null];
    return [
      new Flatten.Segment(this.start, pt),
      new Flatten.Segment(pt, this.end)
    ];
  }
  /**
   * Return middle point of the segment
   * @returns {Point}
   */
  middle() {
    return new Flatten.Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
  }
  /**
   * Get point at given length
   * @param {number} length - The length along the segment
   * @returns {Point}
   */
  pointAtLength(length) {
    if (length > this.length || length < 0) return null;
    if (length == 0) return this.start;
    if (length == this.length) return this.end;
    let factor = length / this.length;
    return new Flatten.Point(
      (this.end.x - this.start.x) * factor + this.start.x,
      (this.end.y - this.start.y) * factor + this.start.y
    );
  }
  distanceToPoint(pt) {
    let [dist, ...rest] = Flatten.Distance.point2segment(pt, this);
    return dist;
  }
  definiteIntegral(ymin = 0) {
    let dx = this.end.x - this.start.x;
    let dy1 = this.start.y - ymin;
    let dy2 = this.end.y - ymin;
    return dx * (dy1 + dy2) / 2;
  }
  /**
   * Return new segment transformed using affine transformation matrix
   * @param {Matrix} matrix - affine transformation matrix
   * @returns {Segment} - transformed segment
   */
  transform(matrix2 = new Flatten.Matrix()) {
    return new Segment(this.ps.transform(matrix2), this.pe.transform(matrix2));
  }
  /**
   * Returns true if segment start is equal to segment end up to DP_TOL
   * @returns {boolean}
   */
  isZeroLength() {
    return this.ps.equalTo(this.pe);
  }
  /**
   * Sort given array of points from segment start to end, assuming all points lay on the segment
   * @param {Point[]} - array of points
   * @returns {Point[]} new array sorted
   */
  sortPoints(pts) {
    let line2 = new Flatten.Line(this.start, this.end);
    return line2.sortPoints(pts);
  }
  get name() {
    return "segment";
  }
  /**
   * Return string to draw segment in svg
   * @param {Object} attrs - an object with attributes for svg path element,
   * like "stroke", "strokeWidth" <br/>
   * Defaults are stroke:"black", strokeWidth:"1"
   * @returns {string}
   */
  svg(attrs = {}) {
    return `
<line x1="${this.start.x}" y1="${this.start.y}" x2="${this.end.x}" y2="${this.end.y}" ${convertToString(attrs)} />`;
  }
};
Flatten.Segment = Segment$1;
var segment = (...args) => new Flatten.Segment(...args);
Flatten.segment = segment;
var { vector } = Flatten;
var Line$1 = class Line extends Shape {
  /**
   * Line may be constructed by point and normal vector or by two points that a line passes through
   * @param {Point} pt - point that a line passes through
   * @param {Vector|Point} norm - normal vector to a line or second point a line passes through
   */
  constructor(...args) {
    super();
    this.pt = new Flatten.Point();
    this.norm = new Flatten.Vector(0, 1);
    if (args.length === 0) {
      return;
    }
    if (args.length === 1 && args[0] instanceof Object && args[0].name === "line") {
      let { pt, norm } = args[0];
      this.pt = new Flatten.Point(pt);
      this.norm = new Flatten.Vector(norm);
      return;
    }
    if (args.length === 2) {
      let a1 = args[0];
      let a2 = args[1];
      if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {
        this.pt = a1;
        this.norm = Line.points2norm(a1, a2);
        if (this.norm.dot(vector(this.pt.x, this.pt.y)) >= 0) {
          this.norm.invert();
        }
        return;
      }
      if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {
        if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {
          throw Errors.ILLEGAL_PARAMETERS;
        }
        this.pt = a1.clone();
        this.norm = a2.clone();
        this.norm = this.norm.normalize();
        if (this.norm.dot(vector(this.pt.x, this.pt.y)) >= 0) {
          this.norm.invert();
        }
        return;
      }
      if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {
        if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {
          throw Errors.ILLEGAL_PARAMETERS;
        }
        this.pt = a2.clone();
        this.norm = a1.clone();
        this.norm = this.norm.normalize();
        if (this.norm.dot(vector(this.pt.x, this.pt.y)) >= 0) {
          this.norm.invert();
        }
        return;
      }
    }
    throw Errors.ILLEGAL_PARAMETERS;
  }
  /**
   * Return new cloned instance of line
   * @returns {Line}
   */
  clone() {
    return new Flatten.Line(this.pt, this.norm);
  }
  /* The following methods need for implementation of Edge interface
  /**
   * Line has no start point
   * @returns {undefined}
   */
  get start() {
    return void 0;
  }
  /**
   * Line has no end point
   */
  get end() {
    return void 0;
  }
  /**
   * Return positive infinity number as length
   * @returns {number}
   */
  get length() {
    return Number.POSITIVE_INFINITY;
  }
  /**
   * Returns infinite box
   * @returns {Box}
   */
  get box() {
    return new Flatten.Box(
      Number.NEGATIVE_INFINITY,
      Number.NEGATIVE_INFINITY,
      Number.POSITIVE_INFINITY,
      Number.POSITIVE_INFINITY
    );
  }
  /**
   * Middle point is undefined
   * @returns {undefined}
   */
  get middle() {
    return void 0;
  }
  /**
   * Slope of the line - angle in radians between line and axe x from 0 to 2PI
   * @returns {number} - slope of the line
   */
  get slope() {
    let vec = new Flatten.Vector(this.norm.y, -this.norm.x);
    return vec.slope;
  }
  /**
   * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C
   * @code [A, B, C] = line.standard
   * @returns {number[]} - array of coefficients
   */
  get standard() {
    let A = this.norm.x;
    let B = this.norm.y;
    let C = this.norm.dot(vector(this.pt.x, this.pt.y));
    return [A, B, C];
  }
  /**
   * Return true if parallel or incident to other line
   * @param {Line} other_line - line to check
   * @returns {boolean}
   */
  parallelTo(other_line) {
    return Flatten.Utils.EQ_0(this.norm.cross(other_line.norm));
  }
  /**
   * Returns true if incident to other line
   * @param {Line} other_line - line to check
   * @returns {boolean}
   */
  incidentTo(other_line) {
    return this.parallelTo(other_line) && this.pt.on(other_line);
  }
  /**
   * Returns true if point belongs to line
   * @param {Point} pt Query point
   * @returns {boolean}
   */
  contains(pt) {
    if (this.pt.equalTo(pt)) {
      return true;
    }
    let vec = new Flatten.Vector(this.pt, pt);
    return Flatten.Utils.EQ_0(this.norm.dot(vec));
  }
  /**
   * Return coordinate of the point that lies on the line in the transformed
   * coordinate system where center is the projection of the point(0,0) to
   * the line and axe y is collinear to the normal vector. <br/>
   * This method assumes that point lies on the line and does not check it
   * @param {Point} pt - point on a line
   * @returns {number}
   */
  coord(pt) {
    return vector(pt.x, pt.y).cross(this.norm);
  }
  /**
   * Returns array of intersection points
   * @param {Shape} shape - shape to intersect with
   * @returns {Point[]}
   */
  intersect(shape) {
    if (shape instanceof Flatten.Point) {
      return this.contains(shape) ? [shape] : [];
    }
    if (shape instanceof Flatten.Line) {
      return intersectLine2Line(this, shape);
    }
    if (shape instanceof Flatten.Ray) {
      return intersectRay2Line(shape, this);
    }
    if (shape instanceof Flatten.Circle) {
      return intersectLine2Circle(this, shape);
    }
    if (shape instanceof Flatten.Box) {
      return intersectLine2Box(this, shape);
    }
    if (shape instanceof Flatten.Segment) {
      return intersectSegment2Line(shape, this);
    }
    if (shape instanceof Flatten.Arc) {
      return intersectLine2Arc(this, shape);
    }
    if (shape instanceof Flatten.Polygon) {
      return intersectLine2Polygon(this, shape);
    }
    if (shape instanceof Flatten.Multiline) {
      return intersectShape2Multiline(this, shape);
    }
  }
  /**
   * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]
   * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon
   * @returns {[number, Segment]}
   */
  distanceTo(shape) {
    if (shape instanceof Flatten.Point) {
      let [distance, shortest_segment] = Flatten.Distance.point2line(shape, this);
      shortest_segment = shortest_segment.reverse();
      return [distance, shortest_segment];
    }
    if (shape instanceof Flatten.Circle) {
      let [distance, shortest_segment] = Flatten.Distance.circle2line(shape, this);
      shortest_segment = shortest_segment.reverse();
      return [distance, shortest_segment];
    }
    if (shape instanceof Flatten.Segment) {
      let [distance, shortest_segment] = Flatten.Distance.segment2line(shape, this);
      return [distance, shortest_segment.reverse()];
    }
    if (shape instanceof Flatten.Arc) {
      let [distance, shortest_segment] = Flatten.Distance.arc2line(shape, this);
      return [distance, shortest_segment.reverse()];
    }
    if (shape instanceof Flatten.Polygon) {
      let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);
      return [distance, shortest_segment];
    }
  }
  /**
   * Split line with a point or array of points and return array of shapes
   * Assumed (but not checked) that all points lay on the line
   * @param {Point | Point[]} pt
   * @returns {MultilineShapes}
   */
  split(pt) {
    if (pt instanceof Flatten.Point) {
      return [new Flatten.Ray(pt, this.norm), new Flatten.Ray(pt, this.norm)];
    } else {
      let multiline2 = new Flatten.Multiline([this]);
      let sorted_points = this.sortPoints(pt);
      multiline2.split(sorted_points);
      return multiline2.toShapes();
    }
  }
  /**
   * Return new line rotated by angle
   * @param {number} angle - angle in radians
   * @param {Point} center - center of rotation
   */
  rotate(angle, center = new Flatten.Point()) {
    return new Flatten.Line(
      this.pt.rotate(angle, center),
      this.norm.rotate(angle)
    );
  }
  /**
   * Return new line transformed by affine transformation matrix
   * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)
   * @returns {Line}
   */
  transform(m) {
    return new Flatten.Line(
      this.pt.transform(m),
      this.norm.clone()
    );
  }
  /**
   * Sort given array of points that lay on a line with respect to coordinate on a line
   * The method assumes that points lay on the line and does not check this
   * @param {Point[]} pts - array of points
   * @returns {Point[]} new array sorted
   */
  sortPoints(pts) {
    return pts.slice().sort((pt1, pt2) => {
      if (this.coord(pt1) < this.coord(pt2)) {
        return -1;
      }
      if (this.coord(pt1) > this.coord(pt2)) {
        return 1;
      }
      return 0;
    });
  }
  get name() {
    return "line";
  }
  /**
   * Return string to draw svg segment representing line inside given box
   * @param {Box} box Box representing drawing area
   * @param {Object} attrs - an object with attributes of svg circle element
   */
  svg(box2, attrs = {}) {
    let ip = intersectLine2Box(this, box2);
    if (ip.length === 0)
      return "";
    let ps = ip[0];
    let pe = ip.length === 2 ? ip[1] : ip.find((pt) => !pt.equalTo(ps));
    if (pe === void 0) pe = ps;
    let segment2 = new Flatten.Segment(ps, pe);
    return segment2.svg(attrs);
  }
  static points2norm(pt1, pt2) {
    if (pt1.equalTo(pt2)) {
      throw Errors.ILLEGAL_PARAMETERS;
    }
    let vec = new Flatten.Vector(pt1, pt2);
    let unit = vec.normalize();
    return unit.rotate90CCW();
  }
};
Flatten.Line = Line$1;
var line = (...args) => new Flatten.Line(...args);
Flatten.line = line;
var Circle$1 = class Circle extends Shape {
  /**
   * Class private property
   * @type {string}
   */
  /**
   *
   * @param {Point} pc - circle center point
   * @param {number} r - circle radius
   */
  constructor(...args) {
    super();
    this.pc = new Flatten.Point();
    this.r = 1;
    if (args.length === 1 && args[0] instanceof Object && args[0].name === "circle") {
      let { pc, r } = args[0];
      this.pc = new Flatten.Point(pc);
      this.r = r;
    } else {
      let [pc, r] = [...args];
      if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();
      if (r !== void 0) this.r = r;
    }
  }
  /**
   * Return new cloned instance of circle
   * @returns {Circle}
   */
  clone() {
    return new Flatten.Circle(this.pc.clone(), this.r);
  }
  /**
   * Circle center
   * @returns {Point}
   */
  get center() {
    return this.pc;
  }
  /**
   * Circle bounding box
   * @returns {Box}
   */
  get box() {
    return new Flatten.Box(
      this.pc.x - this.r,
      this.pc.y - this.r,
      this.pc.x + this.r,
      this.pc.y + this.r
    );
  }
  /**
   * Return true if circle contains shape: no point of shape lies outside of the circle
   * @param {Shape} shape - test shape
   * @returns {boolean}
   */
  contains(shape) {
    if (shape instanceof Flatten.Point) {
      return Flatten.Utils.LE(shape.distanceTo(this.center)[0], this.r);
    }
    if (shape instanceof Flatten.Segment) {
      return Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) && Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);
    }
    if (shape instanceof Flatten.Arc) {
      return this.intersect(shape).length === 0 && Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) && Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);
    }
    if (shape instanceof Flatten.Circle) {
      return this.intersect(shape).length === 0 && Flatten.Utils.LE(shape.r, this.r) && Flatten.Utils.LE(shape.center.distanceTo(this.center)[0], this.r);
    }
  }
  /**
   * Transform circle to closed arc
   * @param {boolean} counterclockwise
   * @returns {Arc}
   */
  toArc(counterclockwise = true) {
    return new Flatten.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);
  }
  /**
   * Method scale is supported only for uniform scaling of the circle with (0,0) center
   * @param {number} sx
   * @param {number} sy
   * @returns {Circle}
   */
  scale(sx, sy) {
    if (sx !== sy)
      throw Errors.OPERATION_IS_NOT_SUPPORTED;
    if (!(this.pc.x === 0 && this.pc.y === 0))
      throw Errors.OPERATION_IS_NOT_SUPPORTED;
    return new Flatten.Circle(this.pc, this.r * sx);
  }
  /**
   * Return new circle transformed using affine transformation matrix
   * @param {Matrix} matrix - affine transformation matrix
   * @returns {Circle}
   */
  transform(matrix2 = new Flatten.Matrix()) {
    return new Flatten.Circle(this.pc.transform(matrix2), this.r);
  }
  /**
   * Returns array of intersection points between circle and other shape
   * @param {Shape} shape Shape of the one of supported types
   * @returns {Point[]}
   */
  intersect(shape) {
    if (shape instanceof Flatten.Point) {
      return this.contains(shape) ? [shape] : [];
    }
    if (shape instanceof Flatten.Line) {
      return intersectLine2Circle(shape, this);
    }
    if (shape instanceof Flatten.Ray) {
      return intersectRay2Circle(shape, this);
    }
    if (shape instanceof Flatten.Segment) {
      return intersectSegment2Circle(shape, this);
    }
    if (shape instanceof Flatten.Circle) {
      return intersectCircle2Circle(shape, this);
    }
    if (shape instanceof Flatten.Box) {
      return intersectCircle2Box(this, shape);
    }
    if (shape instanceof Flatten.Arc) {
      return intersectArc2Circle(shape, this);
    }
    if (shape instanceof Flatten.Polygon) {
      return intersectCircle2Polygon(this, shape);
    }
    if (shape instanceof Flatten.Multiline) {
      return intersectShape2Multiline(this, shape);
    }
  }
  /**
       * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]
       * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set
       * @returns {number} distance from circle to shape
       * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)
  
       */
  distanceTo(shape) {
    if (shape instanceof Flatten.Point) {
      let [distance, shortest_segment] = Flatten.Distance.point2circle(shape, this);
      shortest_segment = shortest_segment.reverse();
      return [distance, shortest_segment];
    }
    if (shape instanceof Flatten.Circle) {
      let [distance, shortest_segment] = Flatten.Distance.circle2circle(this, shape);
      return [distance, shortest_segment];
    }
    if (shape instanceof Flatten.Line) {
      let [distance, shortest_segment] = Flatten.Distance.circle2line(this, shape);
      return [distance, shortest_segment];
    }
    if (shape instanceof Flatten.Segment) {
      let [distance, shortest_segment] = Flatten.Distance.segment2circle(shape, this);
      shortest_segment = shortest_segment.reverse();
      return [distance, shortest_segment];
    }
    if (shape instanceof Flatten.Arc) {
      let [distance, shortest_segment] = Flatten.Distance.arc2circle(shape, this);
      shortest_segment = shortest_segment.reverse();
      return [distance, shortest_segment];
    }
    if (shape instanceof Flatten.Polygon) {
      let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);
      return [distance, shortest_segment];
    }
    if (shape instanceof Flatten.PlanarSet) {
      let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.Multiline) {
      let [dist, shortest_segment] = Flatten.Distance.shape2multiline(this, shape);
      return [dist, shortest_segment];
    }
  }
  get name() {
    return "circle";
  }
  /**
   * Return string to draw circle in svg
   * @param {Object} attrs - an object with attributes of svg circle element
   * @returns {string}
   */
  svg(attrs = {}) {
    return `
<circle cx="${this.pc.x}" cy="${this.pc.y}" r="${this.r}"
                ${convertToString({ fill: "none", ...attrs })} />`;
  }
};
Flatten.Circle = Circle$1;
var circle = (...args) => new Flatten.Circle(...args);
Flatten.circle = circle;
var Arc = class extends Shape {
  /**
   *
   * @param {Point} pc - arc center
   * @param {number} r - arc radius
   * @param {number} startAngle - start angle in radians from 0 to 2*PI
   * @param {number} endAngle - end angle in radians from 0 to 2*PI
   * @param {boolean} counterClockwise - arc direction, true - clockwise, false - counterclockwise
   */
  constructor(...args) {
    super();
    this.pc = new Flatten.Point();
    this.r = 1;
    this.startAngle = 0;
    this.endAngle = 2 * Math.PI;
    this.counterClockwise = Flatten.CCW;
    if (args.length === 0)
      return;
    if (args.length === 1 && args[0] instanceof Object && args[0].name === "arc") {
      let { pc, r, startAngle, endAngle, counterClockwise } = args[0];
      this.pc = new Flatten.Point(pc.x, pc.y);
      this.r = r;
      this.startAngle = startAngle;
      this.endAngle = endAngle;
      this.counterClockwise = counterClockwise;
    } else {
      let [pc, r, startAngle, endAngle, counterClockwise] = [...args];
      if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();
      if (r !== void 0) this.r = r;
      if (startAngle !== void 0) this.startAngle = startAngle;
      if (endAngle !== void 0) this.endAngle = endAngle;
      if (counterClockwise !== void 0) this.counterClockwise = counterClockwise;
    }
  }
  /**
   * Return new cloned instance of arc
   * @returns {Arc}
   */
  clone() {
    return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);
  }
  /**
   * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI
   * @returns {number}
   */
  get sweep() {
    if (Flatten.Utils.EQ(this.startAngle, this.endAngle))
      return 0;
    if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {
      return Flatten.PIx2;
    }
    let sweep;
    if (this.counterClockwise) {
      sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ? this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;
    } else {
      sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ? this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;
    }
    if (Flatten.Utils.GT(sweep, Flatten.PIx2)) {
      sweep -= Flatten.PIx2;
    }
    if (Flatten.Utils.LT(sweep, 0)) {
      sweep += Flatten.PIx2;
    }
    return sweep;
  }
  /**
   * Get start point of arc
   * @returns {Point}
   */
  get start() {
    let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);
    return p0.rotate(this.startAngle, this.pc);
  }
  /**
   * Get end point of arc
   * @returns {Point}
   */
  get end() {
    let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);
    return p0.rotate(this.endAngle, this.pc);
  }
  /**
   * Get center of arc
   * @returns {Point}
   */
  get center() {
    return this.pc.clone();
  }
  get vertices() {
    return [this.start.clone(), this.end.clone()];
  }
  /**
   * Get arc length
   * @returns {number}
   */
  get length() {
    return Math.abs(this.sweep * this.r);
  }
  /**
   * Get bounding box of the arc
   * @returns {Box}
   */
  get box() {
    let func_arcs = this.breakToFunctional();
    let box2 = func_arcs.reduce((acc, arc2) => acc.merge(arc2.start.box), new Flatten.Box());
    box2 = box2.merge(this.end.box);
    return box2;
  }
  /**
   * Returns true if arc contains point, false otherwise
   * @param {Point} pt - point to test
   * @returns {boolean}
   */
  contains(pt) {
    if (!Flatten.Utils.EQ(this.pc.distanceTo(pt)[0], this.r))
      return false;
    if (pt.equalTo(this.start))
      return true;
    let angle = new Flatten.Vector(this.pc, pt).slope;
    let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);
    return Flatten.Utils.LE(test_arc.length, this.length);
  }
  /**
   * When given point belongs to arc, return array of two arcs split by this point. If points is incident
   * to start or end point of the arc, return clone of the arc. If point does not belong to the arcs, return
   * empty array.
   * @param {Point} pt Query point
   * @returns {Arc[]}
   */
  split(pt) {
    if (this.start.equalTo(pt))
      return [null, this.clone()];
    if (this.end.equalTo(pt))
      return [this.clone(), null];
    let angle = new Flatten.Vector(this.pc, pt).slope;
    return [
      new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise),
      new Flatten.Arc(this.pc, this.r, angle, this.endAngle, this.counterClockwise)
    ];
  }
  /**
   * Return middle point of the arc
   * @returns {Point}
   */
  middle() {
    let endAngle = this.counterClockwise ? this.startAngle + this.sweep / 2 : this.startAngle - this.sweep / 2;
    let arc2 = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);
    return arc2.end;
  }
  /**
   * Get point at given length
   * @param {number} length - The length along the arc
   * @returns {Point}
   */
  pointAtLength(length) {
    if (length > this.length || length < 0) return null;
    if (length === 0) return this.start;
    if (length === this.length) return this.end;
    let factor = length / this.length;
    let endAngle = this.counterClockwise ? this.startAngle + this.sweep * factor : this.startAngle - this.sweep * factor;
    let arc2 = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);
    return arc2.end;
  }
  /**
   * Returns chord height ("sagitta") of the arc
   * @returns {number}
   */
  chordHeight() {
    return (1 - Math.cos(Math.abs(this.sweep / 2))) * this.r;
  }
  /**
   * Returns array of intersection points between arc and other shape
   * @param {Shape} shape Shape of the one of supported types <br/>
   * @returns {Point[]}
   */
  intersect(shape) {
    if (shape instanceof Flatten.Point) {
      return this.contains(shape) ? [shape] : [];
    }
    if (shape instanceof Flatten.Line) {
      return intersectLine2Arc(shape, this);
    }
    if (shape instanceof Flatten.Ray) {
      return intersectRay2Arc(shape, this);
    }
    if (shape instanceof Flatten.Circle) {
      return intersectArc2Circle(this, shape);
    }
    if (shape instanceof Flatten.Segment) {
      return intersectSegment2Arc(shape, this);
    }
    if (shape instanceof Flatten.Box) {
      return intersectArc2Box(this, shape);
    }
    if (shape instanceof Flatten.Arc) {
      return intersectArc2Arc(this, shape);
    }
    if (shape instanceof Flatten.Polygon) {
      return intersectArc2Polygon(this, shape);
    }
    if (shape instanceof Flatten.Multiline) {
      return intersectShape2Multiline(this, shape);
    }
  }
  /**
       * Calculate distance and shortest segment from arc to shape and return array [distance, shortest segment]
       * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set
       * @returns {number} distance from arc to shape
       * @returns {Segment} shortest segment between arc and shape (started at arc, ended at shape)
  
       */
  distanceTo(shape) {
    if (shape instanceof Flatten.Point) {
      let [dist, shortest_segment] = Flatten.Distance.point2arc(shape, this);
      shortest_segment = shortest_segment.reverse();
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.Circle) {
      let [dist, shortest_segment] = Flatten.Distance.arc2circle(this, shape);
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.Line) {
      let [dist, shortest_segment] = Flatten.Distance.arc2line(this, shape);
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.Segment) {
      let [dist, shortest_segment] = Flatten.Distance.segment2arc(shape, this);
      shortest_segment = shortest_segment.reverse();
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.Arc) {
      let [dist, shortest_segment] = Flatten.Distance.arc2arc(this, shape);
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.Polygon) {
      let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.PlanarSet) {
      let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.Multiline) {
      return Flatten.Distance.shape2multiline(this, shape);
    }
  }
  /**
   * Breaks arc in extreme point 0, pi/2, pi, 3*pi/2 and returns array of sub-arcs
   * @returns {Arc[]}
   */
  breakToFunctional() {
    let func_arcs_array = [];
    let angles = [0, Math.PI / 2, 2 * Math.PI / 2, 3 * Math.PI / 2];
    let pts = [
      this.pc.translate(this.r, 0),
      this.pc.translate(0, this.r),
      this.pc.translate(-this.r, 0),
      this.pc.translate(0, -this.r)
    ];
    let test_arcs = [];
    for (let i = 0; i < 4; i++) {
      if (pts[i].on(this)) {
        test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));
      }
    }
    if (test_arcs.length === 0) {
      func_arcs_array.push(this.clone());
    } else {
      test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);
      for (let i = 0; i < test_arcs.length; i++) {
        let prev_arc2 = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : void 0;
        let new_arc2;
        if (prev_arc2) {
          new_arc2 = new Flatten.Arc(this.pc, this.r, prev_arc2.endAngle, test_arcs[i].endAngle, this.counterClockwise);
        } else {
          new_arc2 = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);
        }
        if (!Flatten.Utils.EQ_0(new_arc2.length)) {
          func_arcs_array.push(new_arc2.clone());
        }
      }
      let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : void 0;
      let new_arc;
      if (prev_arc) {
        new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);
      } else {
        new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);
      }
      if (!Flatten.Utils.EQ_0(new_arc.length) && !Flatten.Utils.EQ(new_arc.sweep, 2 * Math.PI)) {
        func_arcs_array.push(new_arc.clone());
      }
    }
    return func_arcs_array;
  }
  /**
   * Return tangent unit vector in the start point in the direction from start to end
   * @returns {Vector}
   */
  tangentInStart() {
    let vec = new Flatten.Vector(this.pc, this.start);
    let angle = this.counterClockwise ? Math.PI / 2 : -Math.PI / 2;
    return vec.rotate(angle).normalize();
  }
  /**
   * Return tangent unit vector in the end point in the direction from end to start
   * @returns {Vector}
   */
  tangentInEnd() {
    let vec = new Flatten.Vector(this.pc, this.end);
    let angle = this.counterClockwise ? -Math.PI / 2 : Math.PI / 2;
    return vec.rotate(angle).normalize();
  }
  /**
   * Returns new arc with swapped start and end angles and reversed direction
   * @returns {Arc}
   */
  reverse() {
    return new Flatten.Arc(this.pc, this.r, this.endAngle, this.startAngle, !this.counterClockwise);
  }
  /**
   * Return new arc transformed using affine transformation matrix <br/>
   * @param {Matrix} matrix - affine transformation matrix
   * @returns {Arc}
   */
  transform(matrix2 = new Flatten.Matrix()) {
    let newStart = this.start.transform(matrix2);
    let newEnd = this.end.transform(matrix2);
    let newCenter = this.pc.transform(matrix2);
    let newDirection = this.counterClockwise;
    if (matrix2.a * matrix2.d < 0) {
      newDirection = !newDirection;
    }
    return Flatten.Arc.arcSE(newCenter, newStart, newEnd, newDirection);
  }
  static arcSE(center, start, end, counterClockwise) {
    let { vector: vector2 } = Flatten;
    let startAngle = vector2(center, start).slope;
    let endAngle = vector2(center, end).slope;
    if (Flatten.Utils.EQ(startAngle, endAngle)) {
      endAngle += 2 * Math.PI;
      counterClockwise = true;
    }
    let r = vector2(center, start).length;
    return new Flatten.Arc(center, r, startAngle, endAngle, counterClockwise);
  }
  definiteIntegral(ymin = 0) {
    let f_arcs = this.breakToFunctional();
    let area = f_arcs.reduce((acc, arc2) => acc + arc2.circularSegmentDefiniteIntegral(ymin), 0);
    return area;
  }
  circularSegmentDefiniteIntegral(ymin) {
    let line2 = new Flatten.Line(this.start, this.end);
    let onLeftSide = this.pc.leftTo(line2);
    let segment2 = new Flatten.Segment(this.start, this.end);
    let areaTrapez = segment2.definiteIntegral(ymin);
    let areaCircularSegment = this.circularSegmentArea();
    let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;
    return area;
  }
  circularSegmentArea() {
    return 0.5 * this.r * this.r * (this.sweep - Math.sin(this.sweep));
  }
  /**
   * Sort given array of points from arc start to end, assuming all points lay on the arc
   * @param {Point[]} pts array of points
   * @returns {Point[]} new array sorted
   */
  sortPoints(pts) {
    let { vector: vector2 } = Flatten;
    return pts.slice().sort((pt1, pt2) => {
      let slope1 = vector2(this.pc, pt1).slope;
      let slope2 = vector2(this.pc, pt2).slope;
      if (slope1 < slope2) {
        return -1;
      }
      if (slope1 > slope2) {
        return 1;
      }
      return 0;
    });
  }
  get name() {
    return "arc";
  }
  /**
   * Return string to draw arc in svg
   * @param {Object} attrs - an object with attributes of svg path element
   * @returns {string}
   */
  svg(attrs = {}) {
    let largeArcFlag = this.sweep <= Math.PI ? "0" : "1";
    let sweepFlag = this.counterClockwise ? "1" : "0";
    if (Flatten.Utils.EQ(this.sweep, 2 * Math.PI)) {
      let circle2 = new Flatten.Circle(this.pc, this.r);
      return circle2.svg(attrs);
    } else {
      return `
<path d="M${this.start.x},${this.start.y}
                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}"
                    ${convertToString({ fill: "none", ...attrs })} />`;
    }
  }
};
Flatten.Arc = Arc;
var arc = (...args) => new Flatten.Arc(...args);
Flatten.arc = arc;
var Box = class _Box extends Shape {
  /**
   *
   * @param {number} xmin - minimal x coordinate
   * @param {number} ymin - minimal y coordinate
   * @param {number} xmax - maximal x coordinate
   * @param {number} ymax - maximal y coordinate
   */
  constructor(xmin = void 0, ymin = void 0, xmax = void 0, ymax = void 0) {
    super();
    this.xmin = xmin;
    this.ymin = ymin;
    this.xmax = xmax;
    this.ymax = ymax;
  }
  /**
   * Return new cloned instance of box
   * @returns {Box}
   */
  clone() {
    return new _Box(this.xmin, this.ymin, this.xmax, this.ymax);
  }
  /**
   * Property low need for interval tree interface
   * @returns {Point}
   */
  get low() {
    return new Flatten.Point(this.xmin, this.ymin);
  }
  /**
   * Property high need for interval tree interface
   * @returns {Point}
   */
  get high() {
    return new Flatten.Point(this.xmax, this.ymax);
  }
  /**
   * Property max returns the box itself !
   * @returns {Box}
   */
  get max() {
    return this.clone();
  }
  /**
   * Return center of the box
   * @returns {Point}
   */
  get center() {
    return new Flatten.Point((this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2);
  }
  /**
   * Return the width of the box
   * @returns {number}
   */
  get width() {
    return Math.abs(this.xmax - this.xmin);
  }
  /**
   * Return the height of the box
   * @returns {number}
   */
  get height() {
    return Math.abs(this.ymax - this.ymin);
  }
  /**
   * Return property box like all other shapes
   * @returns {Box}
   */
  get box() {
    return this.clone();
  }
  /**
   * Returns true if not intersected with other box
   * @param {Box} other_box - other box to test
   * @returns {boolean}
   */
  not_intersect(other_box) {
    return this.xmax < other_box.xmin || this.xmin > other_box.xmax || this.ymax < other_box.ymin || this.ymin > other_box.ymax;
  }
  /**
   * Returns true if intersected with other box
   * @param {Box} other_box - Query box
   * @returns {boolean}
   */
  intersect(other_box) {
    return !this.not_intersect(other_box);
  }
  /**
   * Returns new box merged with other box
   * @param {Box} other_box - Other box to merge with
   * @returns {Box}
   */
  merge(other_box) {
    return new _Box(
      this.xmin === void 0 ? other_box.xmin : Math.min(this.xmin, other_box.xmin),
      this.ymin === void 0 ? other_box.ymin : Math.min(this.ymin, other_box.ymin),
      this.xmax === void 0 ? other_box.xmax : Math.max(this.xmax, other_box.xmax),
      this.ymax === void 0 ? other_box.ymax : Math.max(this.ymax, other_box.ymax)
    );
  }
  /**
   * Defines predicate "less than" between two boxes. Need for interval index
   * @param {Box} other_box - other box
   * @returns {boolean} - true if this box less than other box, false otherwise
   */
  less_than(other_box) {
    if (this.low.lessThan(other_box.low))
      return true;
    if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high))
      return true;
    return false;
  }
  /**
   * Returns true if this box is equal to other box, false otherwise
   * @param {Box} other_box - query box
   * @returns {boolean}
   */
  equal_to(other_box) {
    return this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high);
  }
  output() {
    return this.clone();
  }
  static comparable_max(box1, box2) {
    return box1.merge(box2);
  }
  static comparable_less_than(pt1, pt2) {
    return pt1.lessThan(pt2);
  }
  /**
   * Set new values to the box object
   * @param {number} xmin - mininal x coordinate
   * @param {number} ymin - minimal y coordinate
   * @param {number} xmax - maximal x coordinate
   * @param {number} ymax - maximal y coordinate
   */
  set(xmin, ymin, xmax, ymax) {
    this.xmin = xmin;
    this.ymin = ymin;
    this.xmax = xmax;
    this.ymax = ymax;
  }
  /**
   * Transform box into array of points from low left corner in counterclockwise
   * @returns {Point[]}
   */
  toPoints() {
    return [
      new Flatten.Point(this.xmin, this.ymin),
      new Flatten.Point(this.xmax, this.ymin),
      new Flatten.Point(this.xmax, this.ymax),
      new Flatten.Point(this.xmin, this.ymax)
    ];
  }
  /**
   * Transform box into array of segments from low left corner in counterclockwise
   * @returns {Segment[]}
   */
  toSegments() {
    let pts = this.toPoints();
    return [
      new Flatten.Segment(pts[0], pts[1]),
      new Flatten.Segment(pts[1], pts[2]),
      new Flatten.Segment(pts[2], pts[3]),
      new Flatten.Segment(pts[3], pts[0])
    ];
  }
  /**
   * Box rotation is not supported
   * Attempt to rotate box throws error
   * @param {number} angle - angle in radians
   * @param {Point} [center=(0,0)] center
   */
  rotate(angle, center = new Flatten.Point()) {
    throw Errors.OPERATION_IS_NOT_SUPPORTED;
  }
  /**
   * Return new box transformed using affine transformation matrix
   * New box is a bounding box of transformed corner points
   * @param {Matrix} m - affine transformation matrix
   * @returns {Box}
   */
  transform(m = new Flatten.Matrix()) {
    const transformed_points = this.toPoints().map((pt) => pt.transform(m));
    return transformed_points.reduce(
      (new_box, pt) => new_box.merge(pt.box),
      new _Box()
    );
  }
  /**
   * Return true if box contains shape: no point of shape lies outside the box
   * @param {AnyShape} shape - test shape
   * @returns {boolean}
   */
  contains(shape) {
    if (shape instanceof Flatten.Point) {
      return shape.x >= this.xmin && shape.x <= this.xmax && shape.y >= this.ymin && shape.y <= this.ymax;
    }
    if (shape instanceof Flatten.Segment) {
      return shape.vertices.every((vertex) => this.contains(vertex));
    }
    if (shape instanceof Flatten.Box) {
      return shape.toSegments().every((segment2) => this.contains(segment2));
    }
    if (shape instanceof Flatten.Circle) {
      return this.contains(shape.box);
    }
    if (shape instanceof Flatten.Arc) {
      return shape.vertices.every((vertex) => this.contains(vertex)) && shape.toSegments().every((segment2) => intersectSegment2Arc(segment2, shape).length === 0);
    }
    if (shape instanceof Flatten.Line || shape instanceof Flatten.Ray) {
      return false;
    }
    if (shape instanceof Flatten.Multiline) {
      return shape.toShapes().every((shape2) => this.contains(shape2));
    }
    if (shape instanceof Flatten.Polygon) {
      return this.contains(shape.box);
    }
  }
  /**
   * Calculate distance and shortest segment from box to shape and return as array [distance, shortest segment]
   * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set
   * @returns {number} distance from box to shape
   * @returns {Segment} shortest segment between box and shape (started at box, ended at shape)
   */
  distanceTo(shape) {
    const distanceInfos = this.toSegments().map((segment2) => segment2.distanceTo(shape));
    let shortestDistanceInfo = [
      Number.MAX_SAFE_INTEGER,
      null
    ];
    distanceInfos.forEach((distanceInfo) => {
      if (distanceInfo[0] < shortestDistanceInfo[0]) {
        shortestDistanceInfo = distanceInfo;
      }
    });
    return shortestDistanceInfo;
  }
  get name() {
    return "box";
  }
  /**
   * Return string to draw box in svg
   * @param {Object} attrs - an object with attributes of svg rectangle element
   * @returns {string}
   */
  svg(attrs = {}) {
    const width = this.xmax - this.xmin;
    const height = this.ymax - this.ymin;
    return `
<rect x="${this.xmin}" y="${this.ymin}" width="${width}" height="${height}"
                ${convertToString({ fill: "none", ...attrs })} />`;
  }
};
Flatten.Box = Box;
var box = (...args) => new Flatten.Box(...args);
Flatten.box = box;
var Edge = class {
  /**
   * Construct new instance of edge
   * @param {Shape} shape Shape of type Segment or Arc
   */
  constructor(shape) {
    this.shape = shape;
    this.next = void 0;
    this.prev = void 0;
    this.face = void 0;
    this.arc_length = 0;
    this.bvStart = void 0;
    this.bvEnd = void 0;
    this.bv = void 0;
    this.overlap = void 0;
  }
  /**
   * Get edge start point
   */
  get start() {
    return this.shape.start;
  }
  /**
   * Get edge end point
   */
  get end() {
    return this.shape.end;
  }
  /**
   * Get edge length
   */
  get length() {
    return this.shape.length;
  }
  /**
   * Get bounding box of the edge
   * @returns {Box}
   */
  get box() {
    return this.shape.box;
  }
  get isSegment() {
    return this.shape instanceof Flatten.Segment;
  }
  get isArc() {
    return this.shape instanceof Flatten.Arc;
  }
  get isLine() {
    return this.shape instanceof Flatten.Line;
  }
  get isRay() {
    return this.shape instanceof Flatten.Ray;
  }
  /**
   * Get middle point of the edge
   * @returns {Point}
   */
  middle() {
    return this.shape.middle();
  }
  /**
   * Get point at given length
   * @param {number} length - The length along the edge
   * @returns {Point}
   */
  pointAtLength(length) {
    return this.shape.pointAtLength(length);
  }
  /**
   * Returns true if point belongs to the edge, false otherwise
   * @param {Point} pt - test point
   */
  contains(pt) {
    return this.shape.contains(pt);
  }
  /**
   * Set inclusion flag of the edge with respect to another polygon
   * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY
   * @param polygon
   */
  setInclusion(polygon2) {
    if (this.bv !== void 0) return this.bv;
    if (this.shape instanceof Flatten.Line || this.shape instanceof Flatten.Ray) {
      this.bv = Flatten.OUTSIDE;
      return this.bv;
    }
    if (this.bvStart === void 0) {
      this.bvStart = ray_shoot(polygon2, this.start);
    }
    if (this.bvEnd === void 0) {
      this.bvEnd = ray_shoot(polygon2, this.end);
    }
    if (this.bvStart === Flatten.OUTSIDE || this.bvEnd == Flatten.OUTSIDE) {
      this.bv = Flatten.OUTSIDE;
    } else if (this.bvStart === Flatten.INSIDE || this.bvEnd == Flatten.INSIDE) {
      this.bv = Flatten.INSIDE;
    } else {
      let bvMiddle = ray_shoot(polygon2, this.middle());
      this.bv = bvMiddle;
    }
    return this.bv;
  }
  /**
   * Set overlapping between two coincident boundary edges
   * Overlapping flag is one of Flatten.OVERLAP_SAME or Flatten.OVERLAP_OPPOSITE
   * @param edge
   */
  setOverlap(edge) {
    let flag = void 0;
    let shape1 = this.shape;
    let shape2 = edge.shape;
    if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Segment) {
      if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end)) {
        flag = Flatten.OVERLAP_SAME;
      } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start)) {
        flag = Flatten.OVERLAP_OPPOSITE;
      }
    } else if (shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Arc) {
      if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && /*shape1.counterClockwise === shape2.counterClockwise &&*/
      shape1.middle().equalTo(shape2.middle())) {
        flag = Flatten.OVERLAP_SAME;
      } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && /*shape1.counterClockwise !== shape2.counterClockwise &&*/
      shape1.middle().equalTo(shape2.middle())) {
        flag = Flatten.OVERLAP_OPPOSITE;
      }
    } else if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Arc || shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Segment) {
      if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.middle().equalTo(shape2.middle())) {
        flag = Flatten.OVERLAP_SAME;
      } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.middle().equalTo(shape2.middle())) {
        flag = Flatten.OVERLAP_OPPOSITE;
      }
    }
    if (this.overlap === void 0) this.overlap = flag;
    if (edge.overlap === void 0) edge.overlap = flag;
  }
  svg() {
    if (this.shape instanceof Flatten.Segment) {
      return ` L${this.shape.end.x},${this.shape.end.y}`;
    } else if (this.shape instanceof Flatten.Arc) {
      let arc2 = this.shape;
      let largeArcFlag;
      let sweepFlag = arc2.counterClockwise ? "1" : "0";
      if (Flatten.Utils.EQ(arc2.sweep, 2 * Math.PI)) {
        let sign = arc2.counterClockwise ? 1 : -1;
        let halfArc1 = new Flatten.Arc(arc2.pc, arc2.r, arc2.startAngle, arc2.startAngle + sign * Math.PI, arc2.counterClockwise);
        let halfArc2 = new Flatten.Arc(arc2.pc, arc2.r, arc2.startAngle + sign * Math.PI, arc2.endAngle, arc2.counterClockwise);
        largeArcFlag = "0";
        return ` A${halfArc1.r},${halfArc1.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc1.end.x},${halfArc1.end.y}
                    A${halfArc2.r},${halfArc2.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc2.end.x},${halfArc2.end.y}`;
      } else {
        largeArcFlag = arc2.sweep <= Math.PI ? "0" : "1";
        return ` A${arc2.r},${arc2.r} 0 ${largeArcFlag},${sweepFlag} ${arc2.end.x},${arc2.end.y}`;
      }
    }
  }
  toJSON() {
    return this.shape.toJSON();
  }
};
Flatten.Edge = Edge;
var CircularLinkedList = class extends LinkedList {
  constructor(first, last) {
    super(first, last);
    this.setCircularLinks();
  }
  setCircularLinks() {
    if (this.isEmpty()) return;
    this.last.next = this.first;
    this.first.prev = this.last;
  }
  [Symbol.iterator]() {
    let element = void 0;
    return {
      next: () => {
        let value = element ? element : this.first;
        let done = this.first ? element ? element === this.first : false : true;
        element = value ? value.next : void 0;
        return { value, done };
      }
    };
  }
  /**
   * Append new element to the end of the list
   * @param {LinkedListElement} element - new element to be appended
   * @returns {CircularLinkedList}
   */
  append(element) {
    super.append(element);
    this.setCircularLinks();
    return this;
  }
  /**
   * Insert new element to the list after elementBefore
   * @param {LinkedListElement} newElement - new element to be inserted
   * @param {LinkedListElement} elementBefore - element in the list to insert after it
   * @returns {CircularLinkedList}
   */
  insert(newElement, elementBefore) {
    super.insert(newElement, elementBefore);
    this.setCircularLinks();
    return this;
  }
  /**
   * Remove element from the list
   * @param {LinkedListElement} element - element to be removed from the list
   * @returns {CircularLinkedList}
   */
  remove(element) {
    super.remove(element);
    return this;
  }
};
var Face = class _Face extends CircularLinkedList {
  constructor(polygon2, ...args) {
    super();
    this._box = void 0;
    this._orientation = void 0;
    if (args.length === 0) {
      return;
    }
    if (args.length === 1) {
      if (args[0] instanceof Array) {
        let shapes = args[0];
        if (shapes.length === 0)
          return;
        if (shapes.every((shape) => {
          return shape instanceof Flatten.Point;
        })) {
          let segments = _Face.points2segments(shapes);
          this.shapes2face(polygon2.edges, segments);
        } else if (shapes.every((shape) => {
          return shape instanceof Array && shape.length === 2;
        })) {
          let points = shapes.map((shape) => new Flatten.Point(shape[0], shape[1]));
          let segments = _Face.points2segments(points);
          this.shapes2face(polygon2.edges, segments);
        } else if (shapes.every((shape) => {
          return shape instanceof Flatten.Segment || shape instanceof Flatten.Arc;
        })) {
          this.shapes2face(polygon2.edges, shapes);
        } else if (shapes.every((shape) => {
          return shape.name === "segment" || shape.name === "arc";
        })) {
          let flattenShapes = [];
          for (let shape of shapes) {
            let flattenShape;
            if (shape.name === "segment") {
              flattenShape = new Flatten.Segment(shape);
            } else {
              flattenShape = new Flatten.Arc(shape);
            }
            flattenShapes.push(flattenShape);
          }
          this.shapes2face(polygon2.edges, flattenShapes);
        }
      } else if (args[0] instanceof _Face) {
        let face = args[0];
        this.first = face.first;
        this.last = face.last;
        for (let edge of face) {
          polygon2.edges.add(edge);
        }
      } else if (args[0] instanceof Flatten.Circle) {
        this.shapes2face(polygon2.edges, [args[0].toArc(CCW)]);
      } else if (args[0] instanceof Flatten.Box) {
        let box2 = args[0];
        this.shapes2face(polygon2.edges, [
          new Flatten.Segment(new Flatten.Point(box2.xmin, box2.ymin), new Flatten.Point(box2.xmax, box2.ymin)),
          new Flatten.Segment(new Flatten.Point(box2.xmax, box2.ymin), new Flatten.Point(box2.xmax, box2.ymax)),
          new Flatten.Segment(new Flatten.Point(box2.xmax, box2.ymax), new Flatten.Point(box2.xmin, box2.ymax)),
          new Flatten.Segment(new Flatten.Point(box2.xmin, box2.ymax), new Flatten.Point(box2.xmin, box2.ymin))
        ]);
      }
    }
    if (args.length === 2 && args[0] instanceof Flatten.Edge && args[1] instanceof Flatten.Edge) {
      this.first = args[0];
      this.last = args[1];
      this.last.next = this.first;
      this.first.prev = this.last;
      this.setArcLength();
    }
  }
  /**
   * Return array of edges from first to last
   * @returns {Array}
   */
  get edges() {
    return this.toArray();
  }
  /**
   * Return array of shapes which comprise face
   * @returns {Array}
   */
  get shapes() {
    return this.edges.map((edge) => edge.shape.clone());
  }
  /**
   * Return bounding box of the face
   * @returns {Box}
   */
  get box() {
    if (this._box === void 0) {
      let box2 = new Flatten.Box();
      for (let edge of this) {
        box2 = box2.merge(edge.box);
      }
      this._box = box2;
    }
    return this._box;
  }
  /**
   * Get all edges length
   * @returns {number}
   */
  get perimeter() {
    return this.last.arc_length + this.last.length;
  }
  /**
   * Get point on face boundary at given length
   * @param {number} length - The length along the face boundary
   * @returns {Point}
   */
  pointAtLength(length) {
    if (length > this.perimeter || length < 0) return null;
    let point2 = null;
    for (let edge of this) {
      if (length >= edge.arc_length && (edge === this.last || length < edge.next.arc_length)) {
        point2 = edge.pointAtLength(length - edge.arc_length);
        break;
      }
    }
    return point2;
  }
  static points2segments(points) {
    let segments = [];
    for (let i = 0; i < points.length; i++) {
      if (points[i].equalTo(points[(i + 1) % points.length]))
        continue;
      segments.push(new Flatten.Segment(points[i], points[(i + 1) % points.length]));
    }
    return segments;
  }
  shapes2face(edges, shapes) {
    for (let shape of shapes) {
      let edge = new Flatten.Edge(shape);
      this.append(edge);
      edges.add(edge);
    }
  }
  /**
   * Append edge after the last edge of the face (and before the first edge). <br/>
   * @param {Edge} edge - Edge to be appended to the linked list
   * @returns {Face}
   */
  append(edge) {
    super.append(edge);
    this.setOneEdgeArcLength(edge);
    edge.face = this;
    return this;
  }
  /**
   * Insert edge newEdge into the linked list after the edge edgeBefore <br/>
   * @param {Edge} newEdge - Edge to be inserted into linked list
   * @param {Edge} edgeBefore - Edge to insert newEdge after it
   * @returns {Face}
   */
  insert(newEdge, edgeBefore) {
    super.insert(newEdge, edgeBefore);
    this.setOneEdgeArcLength(newEdge);
    newEdge.face = this;
    return this;
  }
  /**
   * Remove the given edge from the linked list of the face <br/>
   * @param {Edge} edge - Edge to be removed
   * @returns {Face}
   */
  remove(edge) {
    super.remove(edge);
    this.setArcLength();
    return this;
  }
  /**
   * Merge current edge with the next edge. Given edge will be extended,
   * next edge after it will be removed. The distortion of the polygon
   * is on the responsibility of the user of this method
   * @param {Edge} edge - edge to be extended
   * @returns {Face}
   */
  merge_with_next_edge(edge) {
    edge.shape.end.x = edge.next.shape.end.x;
    edge.shape.end.y = edge.next.shape.end.y;
    this.remove(edge.next);
    return this;
  }
  /**
   * Reverse orientation of the face: first edge become last and vice a verse,
   * all edges starts and ends swapped, direction of arcs inverted. If face was oriented
   * clockwise, it becomes counterclockwise and vice versa
   */
  reverse() {
    let edges = [];
    let edge_tmp = this.last;
    do {
      edge_tmp.shape = edge_tmp.shape.reverse();
      edges.push(edge_tmp);
      edge_tmp = edge_tmp.prev;
    } while (edge_tmp !== this.last);
    this.first = void 0;
    this.last = void 0;
    for (let edge of edges) {
      if (this.first === void 0) {
        edge.prev = edge;
        edge.next = edge;
        this.first = edge;
        this.last = edge;
      } else {
        edge.prev = this.last;
        this.last.next = edge;
        this.last = edge;
        this.last.next = this.first;
        this.first.prev = this.last;
      }
      this.setOneEdgeArcLength(edge);
    }
    if (this._orientation !== void 0) {
      this._orientation = void 0;
      this._orientation = this.orientation();
    }
  }
  /**
   * Set arc_length property for each of the edges in the face.
   * Arc_length of the edge it the arc length from the first edge of the face
   */
  setArcLength() {
    for (let edge of this) {
      this.setOneEdgeArcLength(edge);
      edge.face = this;
    }
  }
  setOneEdgeArcLength(edge) {
    if (edge === this.first) {
      edge.arc_length = 0;
    } else {
      edge.arc_length = edge.prev.arc_length + edge.prev.length;
    }
  }
  /**
   * Returns the absolute value of the area of the face
   * @returns {number}
   */
  area() {
    return Math.abs(this.signedArea());
  }
  /**
   * Returns signed area of the simple face.
   * Face is simple if it has no self intersections that change its orientation.
   * Then the area will be positive if the orientation of the face is clockwise,
   * and negative if orientation is counterclockwise.
   * It may be zero if polygon is degenerated.
   * @returns {number}
   */
  signedArea() {
    let sArea = 0;
    let ymin = this.box.ymin;
    for (let edge of this) {
      sArea += edge.shape.definiteIntegral(ymin);
    }
    return sArea;
  }
  /**
   * Return face orientation: one of Flatten.ORIENTATION.CCW, Flatten.ORIENTATION.CW, Flatten.ORIENTATION.NOT_ORIENTABLE <br/>
   * According to Green theorem the area of a closed curve may be calculated as double integral,
   * and the sign of the integral will be defined by the direction of the curve.
   * When the integral ("signed area") will be negative, direction is counterclockwise,
   * when positive - clockwise and when it is zero, polygon is not orientable.
   * See {@link https://mathinsight.org/greens_theorem_find_area}
   * @returns {number}
   */
  orientation() {
    if (this._orientation === void 0) {
      let area = this.signedArea();
      if (Flatten.Utils.EQ_0(area)) {
        this._orientation = ORIENTATION.NOT_ORIENTABLE;
      } else if (Flatten.Utils.LT(area, 0)) {
        this._orientation = ORIENTATION.CCW;
      } else {
        this._orientation = ORIENTATION.CW;
      }
    }
    return this._orientation;
  }
  /**
   * Returns true if face of the polygon is simple (no self-intersection points found)
   * NOTE: this method is incomplete because it does not exclude touching points.
   * Self intersection test should check if polygon change orientation in the test point.
   * @param {PlanarSet} edges - reference to polygon edges to provide search index
   * @returns {boolean}
   */
  isSimple(edges) {
    let ip = _Face.getSelfIntersections(this, edges, true);
    return ip.length === 0;
  }
  static getSelfIntersections(face, edges, exitOnFirst = false) {
    let int_points = [];
    for (let edge1 of face) {
      let resp = edges.search(edge1.box);
      for (let edge2 of resp) {
        if (edge1 === edge2)
          continue;
        if (edge2.face !== face)
          continue;
        if (edge1.shape instanceof Flatten.Segment && edge2.shape instanceof Flatten.Segment && (edge1.next === edge2 || edge1.prev === edge2))
          continue;
        let ip = edge1.shape.intersect(edge2.shape);
        for (let pt of ip) {
          if (pt.equalTo(edge1.start) && pt.equalTo(edge2.end) && edge2 === edge1.prev)
            continue;
          if (pt.equalTo(edge1.end) && pt.equalTo(edge2.start) && edge2 === edge1.next)
            continue;
          int_points.push(pt);
          if (exitOnFirst)
            break;
        }
        if (int_points.length > 0 && exitOnFirst)
          break;
      }
      if (int_points.length > 0 && exitOnFirst)
        break;
    }
    return int_points;
  }
  /**
   * Returns edge which contains given point
   * @param {Point} pt - test point
   * @returns {Edge}
   */
  findEdgeByPoint(pt) {
    let edgeFound;
    for (let edge of this) {
      if (pt.equalTo(edge.shape.start)) continue;
      if (pt.equalTo(edge.shape.end) || edge.shape.contains(pt)) {
        edgeFound = edge;
        break;
      }
    }
    return edgeFound;
  }
  /**
   * Returns new polygon created from one face
   * @returns {Polygon}
   */
  toPolygon() {
    return new Flatten.Polygon(this.shapes);
  }
  toJSON() {
    return this.edges.map((edge) => edge.toJSON());
  }
  /**
   * Returns string to be assigned to "d" attribute inside defined "path"
   * @returns {string}
   */
  svg() {
    let svgStr = `M${this.first.start.x},${this.first.start.y}`;
    for (let edge of this) {
      svgStr += edge.svg();
    }
    svgStr += ` z`;
    return svgStr;
  }
};
Flatten.Face = Face;
var Ray = class _Ray extends Shape {
  /**
   * Ray may be constructed by setting an <b>origin</b> point and a <b>normal</b> vector, so that any point <b>x</b>
   * on a ray fit an equation: <br />
   *  (<b>x</b> - <b>origin</b>) * <b>vector</b> = 0 <br />
   * Ray defined by constructor is a right semi-infinite line with respect to the normal vector <br/>
   * If normal vector is omitted ray is considered horizontal (normal vector is (0,1)). <br/>
   * Don't be confused: direction of the normal vector is orthogonal to the ray <br/>
   * @param {Point} pt - start point
   * @param {Vector} norm - normal vector
   */
  constructor(...args) {
    super();
    this.pt = new Flatten.Point();
    this.norm = new Flatten.Vector(0, 1);
    if (args.length === 0) {
      return;
    }
    if (args.length >= 1 && args[0] instanceof Flatten.Point) {
      this.pt = args[0].clone();
    }
    if (args.length === 1) {
      return;
    }
    if (args.length === 2 && args[1] instanceof Flatten.Vector) {
      this.norm = args[1].clone();
      return;
    }
    throw Errors.ILLEGAL_PARAMETERS;
  }
  /**
   * Return new cloned instance of ray
   * @returns {Ray}
   */
  clone() {
    return new _Ray(this.pt, this.norm);
  }
  /**
   * Slope of the ray - angle in radians between ray and axe x from 0 to 2PI
   * @returns {number} - slope of the line
   */
  get slope() {
    let vec = new Flatten.Vector(this.norm.y, -this.norm.x);
    return vec.slope;
  }
  /**
   * Returns half-infinite bounding box of the ray
   * @returns {Box} - bounding box
   */
  get box() {
    let slope = this.slope;
    return new Flatten.Box(
      slope > Math.PI / 2 && slope < 3 * Math.PI / 2 ? Number.NEGATIVE_INFINITY : this.pt.x,
      slope >= 0 && slope <= Math.PI ? this.pt.y : Number.NEGATIVE_INFINITY,
      slope >= Math.PI / 2 && slope <= 3 * Math.PI / 2 ? this.pt.x : Number.POSITIVE_INFINITY,
      slope >= Math.PI && slope <= 2 * Math.PI || slope === 0 ? this.pt.y : Number.POSITIVE_INFINITY
    );
  }
  /**
   * Return ray start point
   * @returns {Point} - ray start point
   */
  get start() {
    return this.pt;
  }
  /**
   * Ray has no end point?
   * @returns {undefined}
   */
  get end() {
    return void 0;
  }
  /**
   * Return positive infinity number as length
   * @returns {number}
   */
  get length() {
    return Number.POSITIVE_INFINITY;
  }
  /**
   * Returns true if point belongs to ray
   * @param {Point} pt Query point
   * @returns {boolean}
   */
  contains(pt) {
    if (this.pt.equalTo(pt)) {
      return true;
    }
    let vec = new Flatten.Vector(this.pt, pt);
    return Flatten.Utils.EQ_0(this.norm.dot(vec)) && Flatten.Utils.GE(vec.cross(this.norm), 0);
  }
  /**
   * Return coordinate of the point that lies on the ray in the transformed
   * coordinate system where center is the projection of the point(0,0) to
   * the line containing this ray and axe y is collinear to the normal vector. <br/>
   * This method assumes that point lies on the ray
   * @param {Point} pt - point on a ray
   * @returns {number}
   */
  coord(pt) {
    return vector$1(pt.x, pt.y).cross(this.norm);
  }
  /**
   * Split ray with point and return array of segment and new ray
   * @param {Point} pt
   * @returns [Segment,Ray]
   */
  split(pt) {
    if (!this.contains(pt))
      return [];
    if (this.pt.equalTo(pt)) {
      return [this];
    }
    return [
      new Flatten.Segment(this.pt, pt),
      new Flatten.Ray(pt, this.norm)
    ];
  }
  /**
   * Returns array of intersection points between ray and another shape
   * @param {Shape} shape - Shape to intersect with ray
   * @returns {Point[]} array of intersection points
   */
  intersect(shape) {
    if (shape instanceof Flatten.Point) {
      return this.contains(shape) ? [shape] : [];
    }
    if (shape instanceof Flatten.Segment) {
      return intersectRay2Segment(this, shape);
    }
    if (shape instanceof Flatten.Arc) {
      return intersectRay2Arc(this, shape);
    }
    if (shape instanceof Flatten.Line) {
      return intersectRay2Line(this, shape);
    }
    if (shape instanceof Flatten.Ray) {
      return intersectRay2Ray(this, shape);
    }
    if (shape instanceof Flatten.Circle) {
      return intersectRay2Circle(this, shape);
    }
    if (shape instanceof Flatten.Box) {
      return intersectRay2Box(this, shape);
    }
    if (shape instanceof Flatten.Polygon) {
      return intersectRay2Polygon(this, shape);
    }
  }
  /**
   * Return new line rotated by angle
   * @param {number} angle - angle in radians
   * @param {Point} center - center of rotation
   */
  rotate(angle, center = new Flatten.Point()) {
    return new Flatten.Ray(
      this.pt.rotate(angle, center),
      this.norm.rotate(angle)
    );
  }
  /**
   * Return new ray transformed by affine transformation matrix
   * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)
   * @returns {Ray}
   */
  transform(m) {
    return new Flatten.Ray(
      this.pt.transform(m),
      this.norm.clone()
    );
  }
  get name() {
    return "ray";
  }
  /**
   * Return string to draw svg segment representing ray inside given box
   * @param {Box} box Box representing drawing area
   * @param {Object} attrs - an object with attributes of svg segment element
   */
  svg(box2, attrs = {}) {
    let line2 = new Flatten.Line(this.pt, this.norm);
    let ip = intersectLine2Box(line2, box2);
    ip = ip.filter((pt) => this.contains(pt));
    if (ip.length === 0 || ip.length === 2)
      return "";
    let segment2 = new Flatten.Segment(this.pt, ip[0]);
    return segment2.svg(attrs);
  }
};
Flatten.Ray = Ray;
var ray = (...args) => new Flatten.Ray(...args);
Flatten.ray = ray;
var Polygon$1 = class Polygon {
  /**
   * Constructor creates new instance of polygon. With no arguments new polygon is empty.<br/>
   * Constructor accepts as argument array that define loop of shapes
   * or array of arrays in case of multi polygon <br/>
   * Loop may be defined in different ways: <br/>
   * - array of shapes of type Segment or Arc <br/>
   * - array of points (Flatten.Point) <br/>
   * - array of numeric pairs which represent points <br/>
   * - box or circle object <br/>
   * Alternatively, it is possible to use polygon.addFace method
   * @param {args} - array of shapes or array of arrays
   */
  constructor() {
    this.faces = new Flatten.PlanarSet();
    this.edges = new Flatten.PlanarSet();
    let args = [...arguments];
    if (args.length === 1 && (args[0] instanceof Array && args[0].length > 0 || args[0] instanceof Flatten.Circle || args[0] instanceof Flatten.Box)) {
      let argsArray = args[0];
      if (args[0] instanceof Array && args[0].every((loop) => {
        return loop instanceof Array;
      })) {
        if (argsArray.every((el) => {
          return el instanceof Array && el.length === 2 && typeof el[0] === "number" && typeof el[1] === "number";
        })) {
          this.faces.add(new Flatten.Face(this, argsArray));
        } else {
          for (let loop of argsArray) {
            if (loop instanceof Array && loop[0] instanceof Array && loop[0].every((el) => {
              return el instanceof Array && el.length === 2 && typeof el[0] === "number" && typeof el[1] === "number";
            })) {
              for (let loop1 of loop) {
                this.faces.add(new Flatten.Face(this, loop1));
              }
            } else {
              this.faces.add(new Flatten.Face(this, loop));
            }
          }
        }
      } else {
        this.faces.add(new Flatten.Face(this, argsArray));
      }
    }
  }
  /**
   * (Getter) Returns bounding box of the polygon
   * @returns {Box}
   */
  get box() {
    return [...this.faces].reduce((acc, face) => acc.merge(face.box), new Flatten.Box());
  }
  /**
   * (Getter) Returns array of vertices
   * @returns {Array}
   */
  get vertices() {
    return [...this.edges].map((edge) => edge.start);
  }
  /**
   * Create new cloned instance of the polygon
   * @returns {Polygon}
   */
  clone() {
    let polygon2 = new Polygon();
    for (let face of this.faces) {
      polygon2.addFace(face.shapes);
    }
    return polygon2;
  }
  /**
   * Return true is polygon has no edges
   * @returns {boolean}
   */
  isEmpty() {
    return this.edges.size === 0;
  }
  /**
   * Return true if polygon is valid for boolean operations
   * Polygon is valid if <br/>
   * 1. All faces are simple polygons (there are no self-intersected polygons) <br/>
   * 2. All faces are orientable and there is no island inside island or hole inside hole - TODO <br/>
   * 3. There is no intersections between faces (excluding touching) - TODO <br/>
   * @returns {boolean}
   */
  isValid() {
    let valid = true;
    for (let face of this.faces) {
      if (!face.isSimple(this.edges)) {
        valid = false;
        break;
      }
    }
    return valid;
  }
  /**
   * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted
   * @returns {number}
   */
  area() {
    let signedArea = [...this.faces].reduce((acc, face) => acc + face.signedArea(), 0);
    return Math.abs(signedArea);
  }
  /**
   * Add new face to polygon. Returns added face
   * @param {Point[]|Segment[]|Arc[]|Circle|Box} args -  new face may be create with one of the following ways: <br/>
   * 1) array of points that describe closed path (edges are segments) <br/>
   * 2) array of shapes (segments and arcs) which describe closed path <br/>
   * 3) circle - will be added as counterclockwise arc <br/>
   * 4) box - will be added as counterclockwise rectangle <br/>
   * You can chain method face.reverse() is you need to change direction of the creates face
   * @returns {Face}
   */
  addFace(...args) {
    let face = new Flatten.Face(this, ...args);
    this.faces.add(face);
    return face;
  }
  /**
   * Delete existing face from polygon
   * @param {Face} face Face to be deleted
   * @returns {boolean}
   */
  deleteFace(face) {
    for (let edge of face) {
      this.edges.delete(edge);
    }
    return this.faces.delete(face);
  }
  /**
   * Clear all faces and create new faces from edges
   */
  recreateFaces() {
    this.faces.clear();
    for (let edge of this.edges) {
      edge.face = null;
    }
    let first;
    let unassignedEdgeFound = true;
    while (unassignedEdgeFound) {
      unassignedEdgeFound = false;
      for (let edge of this.edges) {
        if (edge.face === null) {
          first = edge;
          unassignedEdgeFound = true;
          break;
        }
      }
      if (unassignedEdgeFound) {
        let last = first;
        do {
          last = last.next;
        } while (last.next !== first);
        this.addFace(first, last);
      }
    }
  }
  /**
   * Delete chain of edges from the face.
   * @param {Face} face Face to remove chain
   * @param {Edge} edgeFrom Start of the chain of edges to be removed
   * @param {Edge} edgeTo End of the chain of edges to be removed
   */
  removeChain(face, edgeFrom, edgeTo) {
    if (edgeTo.next === edgeFrom) {
      this.deleteFace(face);
      return;
    }
    for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next) {
      face.remove(edge);
      this.edges.delete(edge);
      if (face.isEmpty()) {
        this.deleteFace(face);
        break;
      }
    }
  }
  /**
   * Add point as a new vertex and split edge. Point supposed to belong to an edge.
   * When edge is split, new edge created from the start of the edge to the new vertex
   * and inserted before current edge.
   * Current edge is trimmed and updated.
   * Method returns new edge added. If no edge added, it returns edge before vertex
   * @param {Point} pt Point to be added as a new vertex
   * @param {Edge} edge Edge to be split with new vertex and then trimmed from start
   * @returns {Edge}
   */
  addVertex(pt, edge) {
    let shapes = edge.shape.split(pt);
    if (shapes[0] === null)
      return edge.prev;
    if (shapes[1] === null)
      return edge;
    let newEdge = new Flatten.Edge(shapes[0]);
    let edgeBefore = edge.prev;
    edge.face.insert(newEdge, edgeBefore);
    this.edges.delete(edge);
    this.edges.add(newEdge);
    edge.shape = shapes[1];
    this.edges.add(edge);
    return newEdge;
  }
  /**
   * Merge given edge with next edge and remove vertex between them
   * @param {Edge} edge
   */
  removeEndVertex(edge) {
    const edge_next = edge.next;
    if (edge_next === edge) return;
    edge.face.merge_with_next_edge(edge);
    this.edges.delete(edge_next);
  }
  /**
   * Cut polygon with multiline and return a new polygon
   * @param {Multiline} multiline
   * @returns {Polygon}
   */
  cut(multiline2) {
    let newPoly = this.clone();
    let intersections = {
      int_points1: [],
      int_points2: [],
      int_points1_sorted: [],
      int_points2_sorted: []
    };
    for (let edge1 of multiline2.edges) {
      for (let edge2 of newPoly.edges) {
        let ip = intersectEdge2Edge(edge1, edge2);
        for (let pt of ip) {
          addToIntPoints(edge1, pt, intersections.int_points1);
          addToIntPoints(edge2, pt, intersections.int_points2);
        }
      }
    }
    if (intersections.int_points1.length === 0)
      return newPoly;
    intersections.int_points1_sorted = getSortedArray(intersections.int_points1);
    intersections.int_points2_sorted = getSortedArray(intersections.int_points2);
    splitByIntersections(multiline2, intersections.int_points1_sorted);
    splitByIntersections(newPoly, intersections.int_points2_sorted);
    filterDuplicatedIntersections(intersections);
    intersections.int_points1_sorted = getSortedArray(intersections.int_points1);
    intersections.int_points2_sorted = getSortedArray(intersections.int_points2);
    initializeInclusionFlags(intersections.int_points1);
    calculateInclusionFlags(intersections.int_points1, newPoly);
    for (let int_point1 of intersections.int_points1_sorted) {
      if (int_point1.edge_before && int_point1.edge_after && int_point1.edge_before.bv === int_point1.edge_after.bv) {
        intersections.int_points2[int_point1.id] = -1;
        int_point1.id = -1;
      }
    }
    intersections.int_points1 = intersections.int_points1.filter((int_point) => int_point.id >= 0);
    intersections.int_points2 = intersections.int_points2.filter((int_point) => int_point.id >= 0);
    intersections.int_points1.forEach((int_point, index) => {
      int_point.id = index;
    });
    intersections.int_points2.forEach((int_point, index) => {
      int_point.id = index;
    });
    if (intersections.int_points1.length === 0)
      return newPoly;
    intersections.int_points1_sorted = getSortedArray(intersections.int_points1);
    intersections.int_points2_sorted = getSortedArray(intersections.int_points2);
    let int_point1_prev;
    let int_point1_curr;
    for (let i = 1; i < intersections.int_points1_sorted.length; i++) {
      int_point1_curr = intersections.int_points1_sorted[i];
      int_point1_prev = intersections.int_points1_sorted[i - 1];
      if (int_point1_curr.edge_before && int_point1_curr.edge_before.bv === INSIDE$2) {
        let edgeFrom = int_point1_prev.edge_after;
        let edgeTo = int_point1_curr.edge_before;
        let newEdges = multiline2.getChain(edgeFrom, edgeTo);
        insertBetweenIntPoints(intersections.int_points2[int_point1_prev.id], intersections.int_points2[int_point1_curr.id], newEdges);
        newEdges.forEach((edge) => newPoly.edges.add(edge));
        newEdges = newEdges.reverse().map((edge) => new Flatten.Edge(edge.shape.reverse()));
        for (let k = 0; k < newEdges.length - 1; k++) {
          newEdges[k].next = newEdges[k + 1];
          newEdges[k + 1].prev = newEdges[k];
        }
        insertBetweenIntPoints(intersections.int_points2[int_point1_curr.id], intersections.int_points2[int_point1_prev.id], newEdges);
        newEdges.forEach((edge) => newPoly.edges.add(edge));
      }
    }
    newPoly.recreateFaces();
    return newPoly;
  }
  /**
   * A special case of cut() function
   * The return is a polygon cut with line
   * @param {Line} line - cutting line
   * @returns {Polygon} newPoly - resulted polygon
   */
  cutWithLine(line2) {
    let multiline2 = new Multiline$1([line2]);
    return this.cut(multiline2);
  }
  /**
   * Returns the first found edge of polygon that contains given point
   * If point is a vertex, return the edge where the point is an end vertex, not a start one
   * @param {Point} pt
   * @returns {Edge}
   */
  findEdgeByPoint(pt) {
    let edge;
    for (let face of this.faces) {
      edge = face.findEdgeByPoint(pt);
      if (edge !== void 0)
        break;
    }
    return edge;
  }
  /**
   * Split polygon into array of polygons, where each polygon is an outer face with all
   * containing inner faces
   * @returns {Flatten.Polygon[]}
   */
  splitToIslands() {
    if (this.isEmpty()) return [];
    let polygons = this.toArray();
    polygons.sort((polygon1, polygon2) => polygon2.area() - polygon1.area());
    let orientation = [...polygons[0].faces][0].orientation();
    let newPolygons = polygons.filter((polygon2) => [...polygon2.faces][0].orientation() === orientation);
    for (let polygon2 of polygons) {
      let face = [...polygon2.faces][0];
      if (face.orientation() === orientation) continue;
      for (let islandPolygon of newPolygons) {
        if (face.shapes.every((shape) => islandPolygon.contains(shape))) {
          islandPolygon.addFace(face.shapes);
          break;
        }
      }
    }
    return newPolygons;
  }
  /**
   * Reverse orientation of all faces to opposite
   * @returns {Polygon}
   */
  reverse() {
    for (let face of this.faces) {
      face.reverse();
    }
    return this;
  }
  /**
   * Returns true if polygon contains shape: no point of shape lay outside of the polygon,
   * false otherwise
   * @param {Shape} shape - test shape
   * @returns {boolean}
   */
  contains(shape) {
    if (shape instanceof Flatten.Point) {
      let rel = ray_shoot(this, shape);
      return rel === INSIDE$2 || rel === BOUNDARY$1;
    } else {
      return cover(this, shape);
    }
  }
  /**
   * Return distance and shortest segment between polygon and other shape as array [distance, shortest_segment]
   * @param {Shape} shape Shape of one of the types Point, Circle, Line, Segment, Arc or Polygon
   * @returns {Number | Segment}
   */
  distanceTo(shape) {
    if (shape instanceof Flatten.Point) {
      let [dist, shortest_segment] = Flatten.Distance.point2polygon(shape, this);
      shortest_segment = shortest_segment.reverse();
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.Circle || shape instanceof Flatten.Line || shape instanceof Flatten.Segment || shape instanceof Flatten.Arc) {
      let [dist, shortest_segment] = Flatten.Distance.shape2polygon(shape, this);
      shortest_segment = shortest_segment.reverse();
      return [dist, shortest_segment];
    }
    if (shape instanceof Flatten.Polygon) {
      let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];
      let dist, shortest_segment;
      for (let edge of this.edges) {
        let min_stop = min_dist_and_segment[0];
        [dist, shortest_segment] = Flatten.Distance.shape2planarSet(edge.shape, shape.edges, min_stop);
        if (Flatten.Utils.LT(dist, min_stop)) {
          min_dist_and_segment = [dist, shortest_segment];
        }
      }
      return min_dist_and_segment;
    }
  }
  /**
   * Return array of intersection points between polygon and other shape
   * @param shape Shape of the one of supported types <br/>
   * @returns {Point[]}
   */
  intersect(shape) {
    if (shape instanceof Flatten.Point) {
      return this.contains(shape) ? [shape] : [];
    }
    if (shape instanceof Flatten.Line) {
      return intersectLine2Polygon(shape, this);
    }
    if (shape instanceof Flatten.Ray) {
      return intersectRay2Polygon(shape, this);
    }
    if (shape instanceof Flatten.Circle) {
      return intersectCircle2Polygon(shape, this);
    }
    if (shape instanceof Flatten.Segment) {
      return intersectSegment2Polygon(shape, this);
    }
    if (shape instanceof Flatten.Arc) {
      return intersectArc2Polygon(shape, this);
    }
    if (shape instanceof Flatten.Polygon) {
      return intersectPolygon2Polygon(shape, this);
    }
    if (shape instanceof Flatten.Multiline) {
      return intersectMultiline2Polygon(shape, this);
    }
  }
  /**
   * Returns new polygon translated by vector vec
   * @param {Vector} vec
   * @returns {Polygon}
   */
  translate(vec) {
    let newPolygon = new Polygon();
    for (let face of this.faces) {
      newPolygon.addFace(face.shapes.map((shape) => shape.translate(vec)));
    }
    return newPolygon;
  }
  /**
   * Return new polygon rotated by given angle around given point
   * If point omitted, rotate around origin (0,0)
   * Positive value of angle defines rotation counterclockwise, negative - clockwise
   * @param {number} angle - rotation angle in radians
   * @param {Point} center - rotation center, default is (0,0)
   * @returns {Polygon} - new rotated polygon
   */
  rotate(angle = 0, center = new Flatten.Point()) {
    let newPolygon = new Polygon();
    for (let face of this.faces) {
      newPolygon.addFace(face.shapes.map((shape) => shape.rotate(angle, center)));
    }
    return newPolygon;
  }
  /**
   * Return new polygon with coordinates multiplied by scaling factor
   * @param {number} sx - x-axis scaling factor
   * @param {number} sy - y-axis scaling factor
   * @returns {Polygon}
   */
  scale(sx, sy) {
    let newPolygon = new Polygon();
    for (let face of this.faces) {
      newPolygon.addFace(face.shapes.map((shape) => shape.scale(sx, sy)));
    }
    return newPolygon;
  }
  /**
   * Return new polygon transformed using affine transformation matrix
   * @param {Matrix} matrix - affine transformation matrix
   * @returns {Polygon} - new polygon
   */
  transform(matrix2 = new Flatten.Matrix()) {
    let newPolygon = new Polygon();
    for (let face of this.faces) {
      newPolygon.addFace(face.shapes.map((shape) => shape.transform(matrix2)));
    }
    return newPolygon;
  }
  /**
   * This method returns an object that defines how data will be
   * serialized when called JSON.stringify() method
   * @returns {Object}
   */
  toJSON() {
    return [...this.faces].map((face) => face.toJSON());
  }
  /**
   * Transform all faces into array of polygons
   * @returns {Flatten.Polygon[]}
   */
  toArray() {
    return [...this.faces].map((face) => face.toPolygon());
  }
  /**
   * Return string to be assigned to 'd' attribute of <path> element
   * @returns {*}
   */
  dpath() {
    return [...this.faces].reduce((acc, face) => acc + face.svg(), "");
  }
  /**
   * Return string to draw polygon in svg
   * @param attrs  - an object with attributes for svg path element
   * @returns {string}
   */
  svg(attrs = {}) {
    let svgStr = `
<path ${convertToString({ fillRule: "evenodd", fill: "lightcyan", ...attrs })} d="`;
    for (let face of this.faces) {
      svgStr += `
${face.svg()}`;
    }
    svgStr += `" >
</path>`;
    return svgStr;
  }
};
Flatten.Polygon = Polygon$1;
var polygon = (...args) => new Flatten.Polygon(...args);
Flatten.polygon = polygon;
var { Circle: Circle2, Line: Line2, Point: Point$2, Vector: Vector2, Utils } = Flatten;
var Inversion = class _Inversion {
  /**
   * Inversion constructor
   * @param {Circle} inversion_circle inversion circle
   */
  constructor(inversion_circle) {
    this.circle = inversion_circle;
  }
  get inversion_circle() {
    return this.circle;
  }
  static inversePoint(inversion_circle, point2) {
    const v = new Vector2(inversion_circle.pc, point2);
    const k2 = inversion_circle.r * inversion_circle.r;
    const len2 = v.dot(v);
    const reflected_point = Utils.EQ_0(len2) ? new Point$2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY) : inversion_circle.pc.translate(v.multiply(k2 / len2));
    return reflected_point;
  }
  static inverseCircle(inversion_circle, circle2) {
    const dist = inversion_circle.pc.distanceTo(circle2.pc)[0];
    if (Utils.EQ(dist, circle2.r)) {
      let d = inversion_circle.r * inversion_circle.r / (2 * circle2.r);
      let v = new Vector2(inversion_circle.pc, circle2.pc);
      v = v.normalize();
      let pt = inversion_circle.pc.translate(v.multiply(d));
      return new Line2(pt, v);
    } else {
      let v = new Vector2(inversion_circle.pc, circle2.pc);
      let s = inversion_circle.r * inversion_circle.r / (v.dot(v) - circle2.r * circle2.r);
      let pc = inversion_circle.pc.translate(v.multiply(s));
      let r = Math.abs(s) * circle2.r;
      return new Circle2(pc, r);
    }
  }
  static inverseLine(inversion_circle, line2) {
    const [dist, shortest_segment] = inversion_circle.pc.distanceTo(line2);
    if (Utils.EQ_0(dist)) {
      return line2.clone();
    } else {
      let r = inversion_circle.r * inversion_circle.r / (2 * dist);
      let v = new Vector2(inversion_circle.pc, shortest_segment.end);
      v = v.multiply(r / dist);
      return new Circle2(inversion_circle.pc.translate(v), r);
    }
  }
  inverse(shape) {
    if (shape instanceof Point$2) {
      return _Inversion.inversePoint(this.circle, shape);
    } else if (shape instanceof Circle2) {
      return _Inversion.inverseCircle(this.circle, shape);
    } else if (shape instanceof Line2) {
      return _Inversion.inverseLine(this.circle, shape);
    }
  }
};
Flatten.Inversion = Inversion;
var inversion = (circle2) => new Flatten.Inversion(circle2);
Flatten.inversion = inversion;
var Distance = class _Distance {
  /**
   * Calculate distance and shortest segment between points
   * @param pt1
   * @param pt2
   * @returns {[number, Flatten.Segment]} - distance and shortest segment
   */
  static point2point(pt1, pt2) {
    return pt1.distanceTo(pt2);
  }
  /**
   * Calculate distance and shortest segment between point and line
   * @param pt
   * @param line
   * @returns {[number, Flatten.Segment]} - distance and shortest segment
   */
  static point2line(pt, line2) {
    let closest_point = pt.projectionOn(line2);
    let vec = new Flatten.Vector(pt, closest_point);
    return [vec.length, new Flatten.Segment(pt, closest_point)];
  }
  /**
   * Calculate distance and shortest segment between point and circle
   * @param pt
   * @param circle
   * @returns {[number, Flatten.Segment]} - distance and shortest segment
   */
  static point2circle(pt, circle2) {
    let [dist2center, shortest_dist] = pt.distanceTo(circle2.center);
    if (Flatten.Utils.EQ_0(dist2center)) {
      return [circle2.r, new Flatten.Segment(pt, circle2.toArc().start)];
    } else {
      let dist = Math.abs(dist2center - circle2.r);
      let v = new Flatten.Vector(circle2.pc, pt).normalize().multiply(circle2.r);
      let closest_point = circle2.pc.translate(v);
      return [dist, new Flatten.Segment(pt, closest_point)];
    }
  }
  /**
   * Calculate distance and shortest segment between point and segment
   * @param pt
   * @param segment
   * @returns {[number, Flatten.Segment]} - distance and shortest segment
   */
  static point2segment(pt, segment2) {
    if (segment2.start.equalTo(segment2.end)) {
      return _Distance.point2point(pt, segment2.start);
    }
    let v_seg = new Flatten.Vector(segment2.start, segment2.end);
    let v_ps2pt = new Flatten.Vector(segment2.start, pt);
    let v_pe2pt = new Flatten.Vector(segment2.end, pt);
    let start_sp = v_seg.dot(v_ps2pt);
    let end_sp = -v_seg.dot(v_pe2pt);
    let dist;
    let closest_point;
    if (Flatten.Utils.GE(start_sp, 0) && Flatten.Utils.GE(end_sp, 0)) {
      let v_unit = segment2.tangentInStart();
      dist = Math.abs(v_unit.cross(v_ps2pt));
      closest_point = segment2.start.translate(v_unit.multiply(v_unit.dot(v_ps2pt)));
      return [dist, new Flatten.Segment(pt, closest_point)];
    } else if (start_sp < 0) {
      return pt.distanceTo(segment2.start);
    } else {
      return pt.distanceTo(segment2.end);
    }
  }
  /**
   * Calculate distance and shortest segment between point and arc
   * @param pt
   * @param arc
   * @returns {[number, Flatten.Segment]} - distance and shortest segment
   */
  static point2arc(pt, arc2) {
    let circle2 = new Flatten.Circle(arc2.pc, arc2.r);
    let dist_and_segment = [];
    let dist, shortest_segment;
    [dist, shortest_segment] = _Distance.point2circle(pt, circle2);
    if (shortest_segment.end.on(arc2)) {
      dist_and_segment.push(_Distance.point2circle(pt, circle2));
    }
    dist_and_segment.push(_Distance.point2point(pt, arc2.start));
    dist_and_segment.push(_Distance.point2point(pt, arc2.end));
    _Distance.sort(dist_and_segment);
    return dist_and_segment[0];
  }
  /**
   * Calculate distance and shortest segment between point and edge
   * @param pt
   * @param edge
   * @returns {[number, Flatten.Segment]}
   */
  static point2edge(pt, edge) {
    return edge.shape instanceof Flatten.Segment ? _Distance.point2segment(pt, edge.shape) : _Distance.point2arc(pt, edge.shape);
  }
  /**
   * Calculate distance and shortest segment between segment and line
   * @param seg
   * @param line
   * @returns {[number, Flatten.Segment]}
   */
  static segment2line(seg, line2) {
    let ip = seg.intersect(line2);
    if (ip.length > 0) {
      return [0, new Flatten.Segment(ip[0], ip[0])];
    }
    let dist_and_segment = [];
    dist_and_segment.push(_Distance.point2line(seg.start, line2));
    dist_and_segment.push(_Distance.point2line(seg.end, line2));
    _Distance.sort(dist_and_segment);
    return dist_and_segment[0];
  }
  /**
   * Calculate distance and shortest segment between two segments
   * @param seg1
   * @param seg2
   * @returns {[number, Flatten.Segment]} - distance and shortest segment
   */
  static segment2segment(seg1, seg2) {
    let ip = intersectSegment2Segment(seg1, seg2);
    if (ip.length > 0) {
      return [0, new Flatten.Segment(ip[0], ip[0])];
    }
    let dist_and_segment = [];
    let dist_tmp, shortest_segment_tmp;
    [dist_tmp, shortest_segment_tmp] = _Distance.point2segment(seg2.start, seg1);
    dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);
    [dist_tmp, shortest_segment_tmp] = _Distance.point2segment(seg2.end, seg1);
    dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);
    dist_and_segment.push(_Distance.point2segment(seg1.start, seg2));
    dist_and_segment.push(_Distance.point2segment(seg1.end, seg2));
    _Distance.sort(dist_and_segment);
    return dist_and_segment[0];
  }
  /**
   * Calculate distance and shortest segment between segment and circle
   * @param seg
   * @param circle
   * @returns {[number, Flatten.Segment]} - distance and shortest segment
   */
  static segment2circle(seg, circle2) {
    let ip = seg.intersect(circle2);
    if (ip.length > 0) {
      return [0, new Flatten.Segment(ip[0], ip[0])];
    }
    let line2 = new Flatten.Line(seg.ps, seg.pe);
    let [dist, shortest_segment] = _Distance.point2line(circle2.center, line2);
    if (Flatten.Utils.GE(dist, circle2.r) && shortest_segment.end.on(seg)) {
      return _Distance.point2circle(shortest_segment.end, circle2);
    } else {
      let [dist_from_start, shortest_segment_from_start] = _Distance.point2circle(seg.start, circle2);
      let [dist_from_end, shortest_segment_from_end] = _Distance.point2circle(seg.end, circle2);
      return Flatten.Utils.LT(dist_from_start, dist_from_end) ? [dist_from_start, shortest_segment_from_start] : [dist_from_end, shortest_segment_from_end];
    }
  }
  /**
   * Calculate distance and shortest segment between segment and arc
   * @param seg
   * @param arc
   * @returns {[number, Flatten.Segment]} - distance and shortest segment
   */
  static segment2arc(seg, arc2) {
    let ip = seg.intersect(arc2);
    if (ip.length > 0) {
      return [0, new Flatten.Segment(ip[0], ip[0])];
    }
    let line2 = new Flatten.Line(seg.ps, seg.pe);
    let circle2 = new Flatten.Circle(arc2.pc, arc2.r);
    let [dist_from_center, shortest_segment_from_center] = _Distance.point2line(circle2.center, line2);
    if (Flatten.Utils.GE(dist_from_center, circle2.r) && shortest_segment_from_center.end.on(seg)) {
      let [dist_from_projection, shortest_segment_from_projection] = _Distance.point2circle(shortest_segment_from_center.end, circle2);
      if (shortest_segment_from_projection.end.on(arc2)) {
        return [dist_from_projection, shortest_segment_from_projection];
      }
    }
    let dist_and_segment = [];
    dist_and_segment.push(_Distance.point2arc(seg.start, arc2));
    dist_and_segment.push(_Distance.point2arc(seg.end, arc2));
    let dist_tmp, segment_tmp;
    [dist_tmp, segment_tmp] = _Distance.point2segment(arc2.start, seg);
    dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);
    [dist_tmp, segment_tmp] = _Distance.point2segment(arc2.end, seg);
    dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);
    _Distance.sort(dist_and_segment);
    return dist_and_segment[0];
  }
  /**
   * Calculate distance and shortest segment between two circles
   * @param circle1
   * @param circle2
   * @returns {[number, Flatten.Segment]} - distance and shortest segment
   */
  static circle2circle(circle1, circle2) {
    let ip = circle1.intersect(circle2);
    if (ip.length > 0) {
      return [0, new Flatten.Segment(ip[0], ip[0])];
    }
    if (circle1.center.equalTo(circle2.center)) {
      let arc1 = circle1.toArc();
      let arc2 = circle2.toArc();
      return _Distance.point2point(arc1.start, arc2.start);
    } else {
      let line2 = new Flatten.Line(circle1.center, circle2.center);
      let ip1 = line2.intersect(circle1);
      let ip2 = line2.intersect(circle2);
      let dist_and_segment = [];
      dist_and_segment.push(_Distance.point2point(ip1[0], ip2[0]));
      dist_and_segment.push(_Distance.point2point(ip1[0], ip2[1]));
      dist_and_segment.push(_Distance.point2point(ip1[1], ip2[0]));
      dist_and_segment.push(_Distance.point2point(ip1[1], ip2[1]));
      _Distance.sort(dist_and_segment);
      return dist_and_segment[0];
    }
  }
  /**
   * Calculate distance and shortest segment between two circles
   * @param circle
   * @param line
   * @returns {[number, Flatten.Segment]} - distance and shortest segment
   */
  static circle2line(circle2, line2) {
    let ip = circle2.intersect(line2);
    if (ip.length > 0) {
      return [0, new Flatten.Segment(ip[0], ip[0])];
    }
    let [dist_from_center, shortest_segment_from_center] = _Distance.point2line(circle2.center, line2);
    let [dist, shortest_segment] = _Distance.point2circle(shortest_segment_from_center.end, circle2);
    shortest_segment = shortest_segment.reverse();
    return [dist, shortest_segment];
  }
  /**
   * Calculate distance and shortest segment between arc and line
   * @param arc
   * @param line
   * @returns {[number, Flatten.Segment]} - distance and shortest segment
   */
  static arc2line(arc2, line2) {
    let ip = line2.intersect(arc2);
    if (ip.length > 0) {
      return [0, new Flatten.Segment(ip[0], ip[0])];
    }
    let circle2 = new Flatten.Circle(arc2.center, arc2.r);
    let [dist_from_center, shortest_segment_from_center] = _Distance.point2line(circle2.center, line2);
    if (Flatten.Utils.GE(dist_from_center, circle2.r)) {
      let [dist_from_projection, shortest_segment_from_projection] = _Distance.point2circle(shortest_segment_from_center.end, circle2);
      if (shortest_segment_from_projection.end.on(arc2)) {
        return [dist_from_projection, shortest_segment_from_projection];
      }
    } else {
      let dist_and_segment = [];
      dist_and_segment.push(_Distance.point2line(arc2.start, line2));
      dist_and_segment.push(_Distance.point2line(arc2.end, line2));
      _Distance.sort(dist_and_segment);
      return dist_and_segment[0];
    }
  }
  /**
   * Calculate distance and shortest segment between arc and circle
   * @param arc
   * @param circle2
   * @returns {[number, Flatten.Segment]} - distance and shortest segment
   */
  static arc2circle(arc2, circle2) {
    let ip = arc2.intersect(circle2);
    if (ip.length > 0) {
      return [0, new Flatten.Segment(ip[0], ip[0])];
    }
    let circle1 = new Flatten.Circle(arc2.center, arc2.r);
    let [dist, shortest_segment] = _Distance.circle2circle(circle1, circle2);
    if (shortest_segment.start.on(arc2)) {
      return [dist, shortest_segment];
    } else {
      let dist_and_segment = [];
      dist_and_segment.push(_Distance.point2circle(arc2.start, circle2));
      dist_and_segment.push(_Distance.point2circle(arc2.end, circle2));
      _Distance.sort(dist_and_segment);
      return dist_and_segment[0];
    }
  }
  /**
   * Calculate distance and shortest segment between two arcs
   * @param arc1
   * @param arc2
   * @returns {[number, Flatten.Segment]} - distance and shortest segment
   */
  static arc2arc(arc1, arc2) {
    let ip = arc1.intersect(arc2);
    if (ip.length > 0) {
      return [0, new Flatten.Segment(ip[0], ip[0])];
    }
    let circle1 = new Flatten.Circle(arc1.center, arc1.r);
    let circle2 = new Flatten.Circle(arc2.center, arc2.r);
    let [dist, shortest_segment] = _Distance.circle2circle(circle1, circle2);
    if (shortest_segment.start.on(arc1) && shortest_segment.end.on(arc2)) {
      return [dist, shortest_segment];
    } else {
      let dist_and_segment = [];
      let dist_tmp, segment_tmp;
      [dist_tmp, segment_tmp] = _Distance.point2arc(arc1.start, arc2);
      if (segment_tmp.end.on(arc2)) {
        dist_and_segment.push([dist_tmp, segment_tmp]);
      }
      [dist_tmp, segment_tmp] = _Distance.point2arc(arc1.end, arc2);
      if (segment_tmp.end.on(arc2)) {
        dist_and_segment.push([dist_tmp, segment_tmp]);
      }
      [dist_tmp, segment_tmp] = _Distance.point2arc(arc2.start, arc1);
      if (segment_tmp.end.on(arc1)) {
        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);
      }
      [dist_tmp, segment_tmp] = _Distance.point2arc(arc2.end, arc1);
      if (segment_tmp.end.on(arc1)) {
        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);
      }
      [dist_tmp, segment_tmp] = _Distance.point2point(arc1.start, arc2.start);
      dist_and_segment.push([dist_tmp, segment_tmp]);
      [dist_tmp, segment_tmp] = _Distance.point2point(arc1.start, arc2.end);
      dist_and_segment.push([dist_tmp, segment_tmp]);
      [dist_tmp, segment_tmp] = _Distance.point2point(arc1.end, arc2.start);
      dist_and_segment.push([dist_tmp, segment_tmp]);
      [dist_tmp, segment_tmp] = _Distance.point2point(arc1.end, arc2.end);
      dist_and_segment.push([dist_tmp, segment_tmp]);
      _Distance.sort(dist_and_segment);
      return dist_and_segment[0];
    }
  }
  /**
   * Calculate distance and shortest segment between point and polygon
   * @param point
   * @param polygon
   * @returns {[number, Flatten.Segment]} - distance and shortest segment
   */
  static point2polygon(point2, polygon2) {
    let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];
    for (let edge of polygon2.edges) {
      let [dist, shortest_segment] = _Distance.point2edge(point2, edge);
      if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {
        min_dist_and_segment = [dist, shortest_segment];
      }
    }
    return min_dist_and_segment;
  }
  static shape2polygon(shape, polygon2) {
    let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];
    for (let edge of polygon2.edges) {
      let [dist, shortest_segment] = shape.distanceTo(edge.shape);
      if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {
        min_dist_and_segment = [dist, shortest_segment];
      }
    }
    return min_dist_and_segment;
  }
  /**
   * Calculate distance and shortest segment between two polygons
   * @param polygon1
   * @param polygon2
   * @returns {[number, Flatten.Segment]} - distance and shortest segment
   */
  static polygon2polygon(polygon1, polygon2) {
    let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];
    for (let edge1 of polygon1.edges) {
      for (let edge2 of polygon2.edges) {
        let [dist, shortest_segment] = edge1.shape.distanceTo(edge2.shape);
        if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {
          min_dist_and_segment = [dist, shortest_segment];
        }
      }
    }
    return min_dist_and_segment;
  }
  /**
   * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes
   * Minimal distance by x is
   *    (box2.xmin - box1.xmax), if box1 is left to box2
   *    (box1.xmin - box2.xmax), if box2 is left to box1
   *    0,                       if box1 and box2 are intersected by x
   * Minimal distance by y is defined in the same way
   *
   * Maximal distance is estimated as a sum of squared dimensions of the merged box
   *
   * @param box1
   * @param box2
   * @returns {Number | Number} - minimal and maximal distance
   */
  static box2box_minmax(box1, box2) {
    let mindist_x = Math.max(Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0));
    let mindist_y = Math.max(Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0));
    let mindist = mindist_x * mindist_x + mindist_y * mindist_y;
    let box3 = box1.merge(box2);
    let dx = box3.xmax - box3.xmin;
    let dy = box3.ymax - box3.ymin;
    let maxdist = dx * dx + dy * dy;
    return [mindist, maxdist];
  }
  static minmax_tree_process_level(shape, level, min_stop, tree) {
    let mindist, maxdist;
    for (let node of level) {
      [mindist, maxdist] = _Distance.box2box_minmax(shape.box, node.item.key);
      if (node.item.value instanceof Flatten.Edge) {
        tree.insert([mindist, maxdist], node.item.value.shape);
      } else {
        tree.insert([mindist, maxdist], node.item.value);
      }
      if (Flatten.Utils.LT(maxdist, min_stop)) {
        min_stop = maxdist;
      }
    }
    if (level.length === 0)
      return min_stop;
    let new_level_left = level.map((node) => node.left.isNil() ? void 0 : node.left).filter((node) => node !== void 0);
    let new_level_right = level.map((node) => node.right.isNil() ? void 0 : node.right).filter((node) => node !== void 0);
    let new_level = [...new_level_left, ...new_level_right].filter((node) => {
      let [mindist2, maxdist2] = _Distance.box2box_minmax(shape.box, node.max);
      return Flatten.Utils.LE(mindist2, min_stop);
    });
    min_stop = _Distance.minmax_tree_process_level(shape, new_level, min_stop, tree);
    return min_stop;
  }
  /**
   * Calculates sorted tree of [mindist, maxdist] intervals between query shape
   * and shapes of the planar set.
   * @param shape
   * @param set
   */
  static minmax_tree(shape, set, min_stop) {
    let tree = new IntervalTree();
    let level = [set.index.root];
    let squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop * min_stop : Number.POSITIVE_INFINITY;
    squared_min_stop = _Distance.minmax_tree_process_level(shape, level, squared_min_stop, tree);
    return tree;
  }
  static minmax_tree_calc_distance(shape, node, min_dist_and_segment) {
    let min_dist_and_segment_new, stop;
    if (node != null && !node.isNil()) {
      [min_dist_and_segment_new, stop] = _Distance.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);
      if (stop) {
        return [min_dist_and_segment_new, stop];
      }
      if (Flatten.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) {
        return [min_dist_and_segment_new, true];
      }
      let [dist, shortest_segment] = _Distance.distance(shape, node.item.value);
      if (Flatten.Utils.LT(dist, min_dist_and_segment_new[0])) {
        min_dist_and_segment_new = [dist, shortest_segment];
      }
      [min_dist_and_segment_new, stop] = _Distance.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);
      return [min_dist_and_segment_new, stop];
    }
    return [min_dist_and_segment, false];
  }
  /**
   * Calculates distance between shape and Planar Set of shapes
   * @param shape
   * @param {PlanarSet} set
   * @param {Number} min_stop
   * @returns {*}
   */
  static shape2planarSet(shape, set, min_stop = Number.POSITIVE_INFINITY) {
    let min_dist_and_segment = [min_stop, new Flatten.Segment()];
    let stop = false;
    if (set instanceof Flatten.PlanarSet) {
      let tree = _Distance.minmax_tree(shape, set, min_stop);
      [min_dist_and_segment, stop] = _Distance.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);
    }
    return min_dist_and_segment;
  }
  static sort(dist_and_segment) {
    dist_and_segment.sort((d1, d2) => {
      if (Flatten.Utils.LT(d1[0], d2[0])) {
        return -1;
      }
      if (Flatten.Utils.GT(d1[0], d2[0])) {
        return 1;
      }
      return 0;
    });
  }
  static distance(shape1, shape2) {
    return shape1.distanceTo(shape2);
  }
  /**
   * Calculate distance and shortest segment any shape and multiline
   * @param shape
   * @param multiline
   * @returns {[number, Flatten.Segment]}
   */
  static shape2multiline(shape, multiline2) {
    let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];
    for (let edge of multiline2) {
      let [dist, shortest_segment] = _Distance.distance(shape, edge.shape);
      if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {
        min_dist_and_segment = [dist, shortest_segment];
      }
    }
    return min_dist_and_segment;
  }
  /**
   * Calculate distance and shortest segment between two multilines
   * @param multiline1
   * @param multiline2
   * @returns {[number, Flatten.Segment]}
   */
  static multiline2multiline(multiline1, multiline2) {
    let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];
    for (let edge1 of multiline1) {
      for (let edge2 of multiline2) {
        let [dist, shortest_segment] = _Distance.distance(edge1.shape, edge2.shape);
        if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {
          min_dist_and_segment = [dist, shortest_segment];
        }
      }
    }
    return min_dist_and_segment;
  }
};
Flatten.Distance = Distance;
var { Multiline: Multiline2, Point: Point$1, Segment: Segment2, Polygon: Polygon2 } = Flatten;
function parseSinglePoint(pointStr) {
  return new Point$1(pointStr.split(" ").map(Number));
}
function parseMultiPoint(multipointStr) {
  return multipointStr.split(", ").map(parseSinglePoint);
}
function parseLineString(lineStr) {
  const points = parseMultiPoint(lineStr);
  let segments = [];
  for (let i = 0; i < points.length - 1; i++) {
    segments.push(new Segment2(points[i], points[i + 1]));
  }
  return new Multiline2(segments);
}
function parseMultiLineString(multilineStr) {
  const lineStrings = multilineStr.replace(/\(\(/, "").replace(/\)\)$/, "").split("), (");
  return lineStrings.map(parseLineString);
}
function parseSinglePolygon(polygonStr) {
  const facesStr = polygonStr.replace(/\(\(/, "").replace(/\)\)$/, "").split("), (");
  const polygon2 = new Polygon2();
  let orientation;
  facesStr.forEach((facesStr2, idx) => {
    let points = facesStr2.split(", ").map((coordStr) => {
      return new Point$1(coordStr.split(" ").map(Number));
    });
    const face = polygon2.addFace(points);
    if (idx === 0) {
      orientation = face.orientation();
    } else {
      if (face.orientation() === orientation) {
        face.reverse();
      }
    }
  });
  return polygon2;
}
function parseMutliPolygon(multiPolygonString) {
  const polygonStrings = multiPolygonString.split(/\)\), \(\(/).map((polygon3) => "((" + polygon3 + "))");
  const polygons = polygonStrings.map(parseSinglePolygon);
  const polygon2 = new Polygon2();
  const faces = polygons.reduce((acc, polygon3) => [...acc, ...polygon3 == null ? void 0 : polygon3.faces], []);
  faces.forEach((face) => polygon2.addFace([...face == null ? void 0 : face.shapes]));
  return polygon2;
}
function parsePolygon(wkt) {
  if (wkt.startsWith("POLYGON")) {
    const polygonStr = wkt.replace(/^POLYGON /, "");
    return parseSinglePolygon(polygonStr);
  } else {
    const multiPolygonString = wkt.replace(/^MULTIPOLYGON \(\(\((.*)\)\)\)$/, "$1");
    return parseMutliPolygon(multiPolygonString);
  }
}
function parseArrayOfPoints(str) {
  const arr = str.split("\n").map((x) => x.match(/\(([^)]+)\)/)[1]);
  return arr.map(parseSinglePoint);
}
function parseArrayOfLineStrings(str) {
  const arr = str.split("\n").map((x) => x.match(/\(([^)]+)\)/)[1]);
  return arr.map(parseLineString).reduce((acc, x) => [...acc, ...x], []);
}
function parseWKT(str) {
  if (str.startsWith("POINT")) {
    const pointStr = str.replace(/^POINT \(/, "").replace(/\)$/, "");
    return parseSinglePoint(pointStr);
  } else if (str.startsWith("MULTIPOINT")) {
    const multiPointStr = str.replace(/^MULTIPOINT \(/, "").replace(/\)$/, "");
    return parseMultiPoint(multiPointStr);
  } else if (str.startsWith("LINESTRING")) {
    const lineStr = str.replace(/^LINESTRING \(/, "").replace(/\)$/, "");
    return parseLineString(lineStr);
  } else if (str.startsWith("MULTILINESTRING")) {
    const multilineStr = str.replace(/^MULTILINESTRING /, "");
    return parseMultiLineString(multilineStr);
  } else if (str.startsWith("POLYGON") || str.startsWith("MULTIPOLYGON")) {
    return parsePolygon(str);
  } else if (str.startsWith("GEOMETRYCOLLECTION")) {
    const regex = /(?<type>POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON) \((?:[^\(\)]|\([^\)]*\))*\)/g;
    const wktArray = str.match(regex);
    if (wktArray[0].startsWith("GEOMETRYCOLLECTION")) {
      wktArray[0] = wktArray[0].replace("GEOMETRYCOLLECTION (", "");
    }
    const flArray = wktArray.map(parseWKT).map((x) => x instanceof Array ? x : [x]);
    return flArray.reduce((acc, x) => [...acc, ...x], []);
  } else if (isArrayOfPoints(str)) {
    return parseArrayOfPoints(str);
  } else if (isArrayOfLines(str)) {
    return parseArrayOfLineStrings(str);
  }
  return [];
}
function isArrayOfPoints(str) {
  var _a;
  return (_a = str.split("\n")) == null ? void 0 : _a.every((str2) => str2.includes("POINT"));
}
function isArrayOfLines(str) {
  var _a;
  return (_a = str.split("\n")) == null ? void 0 : _a.every((str2) => str2.includes("LINESTRING"));
}
function isWktString(str) {
  return str.startsWith("POINT") || isArrayOfPoints(str) || str.startsWith("LINESTRING") || isArrayOfLines(str) || str.startsWith("MULTILINESTRING") || str.startsWith("POLYGON") || str.startsWith("MULTIPOINT") || str.startsWith("MULTIPOLYGON") || str.startsWith("GEOMETRYCOLLECTION");
}
Flatten.isWktString = isWktString;
Flatten.parseWKT = parseWKT;
Flatten.BooleanOperations = BooleanOperations;
Flatten.Relations = Relations;

export {
  CCW,
  CW,
  ORIENTATION,
  INSIDE$2,
  OUTSIDE$1,
  BOUNDARY$1,
  OVERLAP_SAME$1,
  OVERLAP_OPPOSITE$1,
  Utils$1,
  Flatten,
  Errors,
  Multiline$1,
  multiline,
  smart_intersections,
  BooleanOperations,
  ray_shoot,
  Relations,
  Matrix,
  matrix,
  PlanarSet,
  Point$3,
  point,
  Vector$1,
  vector$1,
  Segment$1,
  segment,
  Line$1,
  line,
  Circle$1,
  circle,
  Arc,
  arc,
  Box,
  box,
  Edge,
  Face,
  Ray,
  ray,
  Polygon$1,
  polygon,
  Inversion,
  inversion,
  Distance,
  parseWKT,
  isWktString
};
//# sourceMappingURL=chunk-SBMZWBFG.js.map
