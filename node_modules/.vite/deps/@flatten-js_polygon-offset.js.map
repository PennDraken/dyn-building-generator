{
  "version": 3,
  "sources": ["../../@flatten-js/polygon-offset/dist/main.esm.js"],
  "sourcesContent": ["import { vector, Utils, Arc, Polygon, CW, CCW, Segment, Face, OUTSIDE, INSIDE, ORIENTATION, Vector, BooleanOperations, SmartIntersections } from '@flatten-js/core';\n\nfunction arcSE(center, start, end, counterClockwise) {\n    let startAngle = vector(center,start).slope;\n    let endAngle = vector(center, end).slope;\n    if (Utils.EQ(startAngle, endAngle)) {\n        endAngle += 2*Math.PI;\n        counterClockwise = true;\n    }\n    let r = vector(center, start).length;\n\n    return new Arc(center, r, startAngle, endAngle, counterClockwise);\n}\n\nfunction arcStartSweep(center, start, sweep, counterClockwise) {\n    let startAngle = vector(center,start).slope;\n    let endAngle = startAngle + sweep;\n    if (Utils.EQ(startAngle, endAngle)) {\n        endAngle += 2*Math.PI;\n        counterClockwise = true;\n    }\n    else if (Utils.GT(endAngle, 2*Math.PI)) {\n        endAngle -= 2*Math.PI;\n    }\n    else if (Utils.LT(endAngle, -2*Math.PI)) {\n        endAngle += 2*Math.PI;\n    }\n    let r = vector(center, start).length;\n\n    return new Arc(center, r, startAngle, endAngle, counterClockwise);\n}\n\nfunction arcEndSweep(center, end, sweep, counterClockwise) {\n    let endAngle = vector(center,end).slope;\n    let startAngle = endAngle - sweep;\n    if (Utils.EQ(startAngle, endAngle)) {\n        startAngle += 2*Math.PI;\n        counterClockwise = true;\n    }\n    else if (Utils.GT(startAngle, 2*Math.PI)) {\n        startAngle -= 2*Math.PI;\n    }\n    else if (Utils.LT(startAngle, -2*Math.PI)) {\n        startAngle += 2*Math.PI;\n    }\n\n    let r = vector(center, end).length;\n\n    return new Arc(center, r, startAngle, endAngle, counterClockwise);\n}\n\n/**\n * Created by Alex Bol on 12/02/2018.\n */\n\n\nconst {unify, subtract, BOOLEAN_UNION} = BooleanOperations;\nconst {addToIntPoints, getSortedArray, splitByIntersections} = SmartIntersections;\nconst {removeNotRelevantChains, removeOldFaces, restoreFaces} = BooleanOperations;\n\n/**\n * Offset polygon by given value\n * @param {Polygon} polygon - input polygon\n * @param {number} value - offset value, may be positive or negative\n * @returns {Polygon} offsetPolygon\n */\n\n/**\n *\n * @param polygon\n * @param value\n *\n */\nfunction offset(polygon, value) {\n    let w = value;\n\n    let edges = [...polygon.edges];\n    let offsetPolygon = polygon.clone();\n    let offsetEdge;\n\n    if (w != 0) {\n        // let counter = 0\n        for (let edge of edges) {\n            if (edge.isSegment()) {\n                offsetEdge = offsetSegment(edge.shape, w);\n            }\n            else {\n                offsetEdge = offsetArc(edge.shape, w);\n            }\n\n            if (w > 0) {\n                offsetPolygon = unify(offsetPolygon, offsetEdge);\n            }\n            else {\n                offsetPolygon = subtract(offsetPolygon, offsetEdge);\n            }\n            // counter++;\n        }\n    }\n\n    return offsetPolygon;\n}\n\nfunction offsetArc(arc, value) {\n\n    let w = Math.abs(value);\n\n    // Define outline polygon\n    let polygon = new Polygon();\n    let arc_cap1,arc_cap2;\n\n    let arc_outer = arc.clone();\n    arc_outer.r = arc.r + w;\n\n    arc_cap1 = arcStartSweep(arc.end, arc_outer.end, Math.PI, arc.counterClockwise);\n    arc_cap2 = arcEndSweep(arc.start, arc_outer.start, Math.PI, arc.counterClockwise);\n\n    let arc_inner = undefined;\n    if (arc.r > w) {\n        arc_inner = new Arc(arc.pc, arc.r - w, arc.endAngle, arc.startAngle,\n            arc.counterClockwise === CW ? CCW : CW);\n    }\n    else {\n        arc_inner = new Segment(arc_cap1.end, arc_cap2.start);\n    }\n\n    polygon.addFace([arc_outer, arc_cap1, arc_inner, arc_cap2]);\n    [...polygon.faces][0].setArcLength();\n\n    // Create intersection points\n    let ips = Face.getSelfIntersections([...polygon.faces][0], polygon.edges, false);\n\n    // TODO: getSelfIntersections returns points with correspondent edges - avoid duplication\n    ips = ips.slice(0,ips.length/2);    // for now slice array to avoid duplication in points\n\n    let int_points = [];\n    let edge_cap1;\n    let edge_cap2;\n\n    edge_cap1 = [...polygon.edges][1];\n    edge_cap2 = [...polygon.edges][3];\n\n    for (let pt of ips) {\n        addToIntPoints(edge_cap1, pt, int_points);\n        addToIntPoints(edge_cap2, pt, int_points);\n    }\n\n    // Sort intersection points and insert them as new vertices\n    let int_points_sorted = getSortedArray(int_points);\n    splitByIntersections(polygon, int_points_sorted);\n\n\n    // Set BV flags\n    let bv = OUTSIDE;\n    for (let int_point of int_points_sorted) {\n        int_point.edge_before.bv = bv;\n        int_point.edge_after.bv = (bv == OUTSIDE ? INSIDE : OUTSIDE);\n        bv = int_point.edge_after.bv;   // invert flag on each iteration\n    }\n\n    // Remove inner \"chains\"\n    let op = BOOLEAN_UNION;\n    removeNotRelevantChains(polygon, op, int_points_sorted, true);\n\n    // return int_points_sorted;\n    // Swap links\n    let num = int_points.length;\n    if (num > 0) {\n        let edge_before;\n        let edge_after;\n        // 0 => 3\n        edge_before = int_points_sorted[0].edge_before;\n        edge_after = int_points_sorted[num-1].edge_after;\n        edge_before.next = edge_after;\n        edge_after.prev = edge_before;\n\n        // Fill in missed links in intersection points\n        int_points_sorted[0].edge_after = int_points_sorted[num-1].edge_after;\n        int_points_sorted[num-1].edge_before = int_points_sorted[0].edge_before;\n\n        if (num == 4) {\n            // 2 => 1\n            edge_before = int_points_sorted[2].edge_before;\n            edge_after = int_points_sorted[1].edge_after;\n            edge_before.next = edge_after;\n            edge_after.prev = edge_before;\n\n            // Fill in missed links in intersection points\n            int_points_sorted[2].edge_after = int_points_sorted[1].edge_after;\n            int_points_sorted[1].edge_before = int_points_sorted[2].edge_before;\n        }\n\n        // remove old faces\n        removeOldFaces(polygon, int_points);\n        // restore faces\n        restoreFaces(polygon, int_points, int_points);\n    }\n\n    let face0 = [...polygon.faces][0];\n    if (face0.orientation() === ORIENTATION.CCW) {\n        polygon.reverse();\n    }\n    return polygon;\n}\n\nfunction offsetSegment(seg, value) {\n    let w = Math.abs(value);\n\n    let polygon = new Polygon();\n    let v_seg = new Vector(seg.end.x-seg.start.x, seg.end.y-seg.start.y);\n    let v_seg_unit = v_seg.normalize();\n    let v_left = v_seg_unit.rotate90CCW().multiply(w);\n    let v_right = v_seg_unit.rotate90CW().multiply(w);\n    let seg_left = seg.translate(v_left);\n    let seg_right = seg.translate(v_right).reverse();\n    let cap1 = arcSE(seg.end, seg_left.end, seg_right.start, CW);\n    let cap2 = arcSE(seg.start, seg_right.end, seg_left.start, CW);\n\n    polygon.addFace([seg_left, cap1, seg_right, cap2]);\n    return polygon;\n}\n\nexport { offset as default };\n"],
  "mappings": "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",
  "names": []
}
